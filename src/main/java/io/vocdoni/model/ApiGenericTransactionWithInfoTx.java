/*
 * Vocdoni API
 * The Vocdoni API is a REST API that substitutes the previous RPCs in order to make it easier for  developers/integrators to build on top of the voting protocol. This API facilitates creating votings using Vocdoni, without the hassle of learning a complex blockchain platform, allowing to perform all the features that enable the voting protocol such as creating an account, entity, voting process, census & vote, abstracting as much as possible the complexity and offering simple and straightforward methods to perform those actions.   You can review the API endpoints documentation in this section, the main entities are:  - [**Chain**](chain): The Vocdoni blockchain is named Vochain. It is a Byzantine fault-tolerant network based on Tendermint that executes the Vocdoni Protocol logic represented as a state machine. Its main purpose is to register votes in a  decentralized and verifiable format. In those endpoints, you can consult the state of the chain, transactions costs,  list organizations and get more Vochain info. - [**Accounts**](accounts): Identified by an Ethereum like address. An account can create and manage elections, transfer tokens, give power to other accounts on his behalf (delegates) and manage its metadata. - [**Elections**](elections): Is a rule-set of options and requirements for creating a process in which people vote a series of options. To know more about the params of an election and its lifecycle go [here](../get-started/intro#23-elections). In this section you will find all information related to an election as its information, election keys, submitted votes & how to create a new election. - [**Censuses**](censuses): The census is a key component of any voting process. It specifies the set of users (identified by a public key or address) eligible for participating in an election. To understand more about the Censuses you can check [here](../get-started/intro#21-the-census). Here you will be able to get censuses information like the Merkle root, total weight & size, import/export the censuses and create new ones. - [**Votes**](votes): All the information related to the vote issued by a participant in a vote, you can check the validity of the vote, consult your information and send a vote. - [**SIK**](sik): The Secret Identity Key is a user-generated piece of information that proves the user's identity without revealing it. It is the hash of the user's address, the signature of a public message and an optional secret part. It is used to ensure anonymous voting. All registered accounts or anonymous voters must register a SIK, and they are all stored in a Merkle tree. The `/siks` endpoints help to generate a proof of membership, get the current valid SIK roots, or check if an account has a valid SIK.   ### Errors   Backend error messages list are defined here: https://github.com/vocdoni/vocdoni-node/blob/master/api/errors.go  About the **204 no content** error: this message will be returned only if the asset being queried cannot be found but no other errors have occurred. This response is commonly used to prevent Javascript errors that may arise when a client is waiting for a  transaction to be published. During this waiting period, the client can repeatedly query the endpoint until a  successful response with a status code of 200 is received, thereby avoiding any errors that may occur due to the transaction not being published yet.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.vocdoni.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.vocdoni.model.ModelsAdminTx;
import io.vocdoni.model.ModelsCollectFaucetTx;
import io.vocdoni.model.ModelsRegisterKeyTx;
import io.vocdoni.model.ModelsSendTokensTx;
import io.vocdoni.model.ModelsSetAccountTx;
import io.vocdoni.model.ModelsSetKeykeeperTx;
import io.vocdoni.model.ModelsSetProcessTx;
import io.vocdoni.model.ModelsSetTransactionCostsTx;
import io.vocdoni.model.ModelsTxAdmin;
import io.vocdoni.model.ModelsTxCollectFaucet;
import io.vocdoni.model.ModelsTxRegisterKey;
import io.vocdoni.model.ModelsTxSendTokens;
import io.vocdoni.model.ModelsTxSetAccount;
import io.vocdoni.model.ModelsTxSetKeykeeper;
import io.vocdoni.model.ModelsTxSetProcess;
import io.vocdoni.model.ModelsTxSetTransactionCosts;
import io.vocdoni.model.ModelsTxVote;
import io.vocdoni.model.ModelsVoteEnvelope;
import java.io.IOException;
import java.util.Arrays;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import io.vocdoni.invoker.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-02-09T17:09:26.351036+01:00[Europe/Prague]")
public class ApiGenericTransactionWithInfoTx extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(ApiGenericTransactionWithInfoTx.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!ApiGenericTransactionWithInfoTx.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'ApiGenericTransactionWithInfoTx' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<ModelsTxVote> adapterModelsTxVote = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxVote.class));
            final TypeAdapter<ModelsTxAdmin> adapterModelsTxAdmin = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxAdmin.class));
            final TypeAdapter<ModelsTxSetProcess> adapterModelsTxSetProcess = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxSetProcess.class));
            final TypeAdapter<ModelsTxRegisterKey> adapterModelsTxRegisterKey = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxRegisterKey.class));
            final TypeAdapter<ModelsTxSendTokens> adapterModelsTxSendTokens = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxSendTokens.class));
            final TypeAdapter<ModelsTxSetTransactionCosts> adapterModelsTxSetTransactionCosts = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxSetTransactionCosts.class));
            final TypeAdapter<ModelsTxSetAccount> adapterModelsTxSetAccount = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxSetAccount.class));
            final TypeAdapter<ModelsTxCollectFaucet> adapterModelsTxCollectFaucet = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxCollectFaucet.class));
            final TypeAdapter<ModelsTxSetKeykeeper> adapterModelsTxSetKeykeeper = gson.getDelegateAdapter(this, TypeToken.get(ModelsTxSetKeykeeper.class));

            return (TypeAdapter<T>) new TypeAdapter<ApiGenericTransactionWithInfoTx>() {
                @Override
                public void write(JsonWriter out, ApiGenericTransactionWithInfoTx value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `ModelsTxVote`
                    if (value.getActualInstance() instanceof ModelsTxVote) {
                      JsonElement element = adapterModelsTxVote.toJsonTree((ModelsTxVote)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxAdmin`
                    if (value.getActualInstance() instanceof ModelsTxAdmin) {
                      JsonElement element = adapterModelsTxAdmin.toJsonTree((ModelsTxAdmin)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxSetProcess`
                    if (value.getActualInstance() instanceof ModelsTxSetProcess) {
                      JsonElement element = adapterModelsTxSetProcess.toJsonTree((ModelsTxSetProcess)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxRegisterKey`
                    if (value.getActualInstance() instanceof ModelsTxRegisterKey) {
                      JsonElement element = adapterModelsTxRegisterKey.toJsonTree((ModelsTxRegisterKey)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxSendTokens`
                    if (value.getActualInstance() instanceof ModelsTxSendTokens) {
                      JsonElement element = adapterModelsTxSendTokens.toJsonTree((ModelsTxSendTokens)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxSetTransactionCosts`
                    if (value.getActualInstance() instanceof ModelsTxSetTransactionCosts) {
                      JsonElement element = adapterModelsTxSetTransactionCosts.toJsonTree((ModelsTxSetTransactionCosts)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxSetAccount`
                    if (value.getActualInstance() instanceof ModelsTxSetAccount) {
                      JsonElement element = adapterModelsTxSetAccount.toJsonTree((ModelsTxSetAccount)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxCollectFaucet`
                    if (value.getActualInstance() instanceof ModelsTxCollectFaucet) {
                      JsonElement element = adapterModelsTxCollectFaucet.toJsonTree((ModelsTxCollectFaucet)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `ModelsTxSetKeykeeper`
                    if (value.getActualInstance() instanceof ModelsTxSetKeykeeper) {
                      JsonElement element = adapterModelsTxSetKeykeeper.toJsonTree((ModelsTxSetKeykeeper)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote");
                }

                @Override
                public ApiGenericTransactionWithInfoTx read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize ModelsTxVote
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxVote.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxVote;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxVote'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxVote failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxVote'", e);
                    }
                    // deserialize ModelsTxAdmin
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxAdmin.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxAdmin;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxAdmin'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxAdmin failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxAdmin'", e);
                    }
                    // deserialize ModelsTxSetProcess
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxSetProcess.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxSetProcess;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxSetProcess'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxSetProcess failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxSetProcess'", e);
                    }
                    // deserialize ModelsTxRegisterKey
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxRegisterKey.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxRegisterKey;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxRegisterKey'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxRegisterKey failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxRegisterKey'", e);
                    }
                    // deserialize ModelsTxSendTokens
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxSendTokens.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxSendTokens;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxSendTokens'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxSendTokens failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxSendTokens'", e);
                    }
                    // deserialize ModelsTxSetTransactionCosts
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxSetTransactionCosts.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxSetTransactionCosts;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxSetTransactionCosts'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxSetTransactionCosts failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxSetTransactionCosts'", e);
                    }
                    // deserialize ModelsTxSetAccount
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxSetAccount.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxSetAccount;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxSetAccount'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxSetAccount failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxSetAccount'", e);
                    }
                    // deserialize ModelsTxCollectFaucet
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxCollectFaucet.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxCollectFaucet;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxCollectFaucet'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxCollectFaucet failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxCollectFaucet'", e);
                    }
                    // deserialize ModelsTxSetKeykeeper
                    try {
                      // validate the JSON object to see if any exception is thrown
                      ModelsTxSetKeykeeper.validateJsonElement(jsonElement);
                      actualAdapter = adapterModelsTxSetKeykeeper;
                      match++;
                      log.log(Level.FINER, "Input data matches schema 'ModelsTxSetKeykeeper'");
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for ModelsTxSetKeykeeper failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'ModelsTxSetKeykeeper'", e);
                    }

                    if (match == 1) {
                        ApiGenericTransactionWithInfoTx ret = new ApiGenericTransactionWithInfoTx();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for ApiGenericTransactionWithInfoTx: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public ApiGenericTransactionWithInfoTx() {
        super("oneOf", Boolean.FALSE);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxAdmin o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxCollectFaucet o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxRegisterKey o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxSendTokens o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxSetAccount o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxSetKeykeeper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxSetProcess o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxSetTransactionCosts o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiGenericTransactionWithInfoTx(ModelsTxVote o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("ModelsTxVote", ModelsTxVote.class);
        schemas.put("ModelsTxAdmin", ModelsTxAdmin.class);
        schemas.put("ModelsTxSetProcess", ModelsTxSetProcess.class);
        schemas.put("ModelsTxRegisterKey", ModelsTxRegisterKey.class);
        schemas.put("ModelsTxSendTokens", ModelsTxSendTokens.class);
        schemas.put("ModelsTxSetTransactionCosts", ModelsTxSetTransactionCosts.class);
        schemas.put("ModelsTxSetAccount", ModelsTxSetAccount.class);
        schemas.put("ModelsTxCollectFaucet", ModelsTxCollectFaucet.class);
        schemas.put("ModelsTxSetKeykeeper", ModelsTxSetKeykeeper.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return ApiGenericTransactionWithInfoTx.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof ModelsTxVote) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxAdmin) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxSetProcess) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxRegisterKey) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxSendTokens) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxSetTransactionCosts) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxSetAccount) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxCollectFaucet) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ModelsTxSetKeykeeper) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote");
    }

    /**
     * Get the actual instance, which can be the following:
     * ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote
     *
     * @return The actual instance (ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `ModelsTxVote`. If the actual instance is not `ModelsTxVote`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxVote`
     * @throws ClassCastException if the instance is not `ModelsTxVote`
     */
    public ModelsTxVote getModelsTxVote() throws ClassCastException {
        return (ModelsTxVote)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxAdmin`. If the actual instance is not `ModelsTxAdmin`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxAdmin`
     * @throws ClassCastException if the instance is not `ModelsTxAdmin`
     */
    public ModelsTxAdmin getModelsTxAdmin() throws ClassCastException {
        return (ModelsTxAdmin)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxSetProcess`. If the actual instance is not `ModelsTxSetProcess`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxSetProcess`
     * @throws ClassCastException if the instance is not `ModelsTxSetProcess`
     */
    public ModelsTxSetProcess getModelsTxSetProcess() throws ClassCastException {
        return (ModelsTxSetProcess)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxRegisterKey`. If the actual instance is not `ModelsTxRegisterKey`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxRegisterKey`
     * @throws ClassCastException if the instance is not `ModelsTxRegisterKey`
     */
    public ModelsTxRegisterKey getModelsTxRegisterKey() throws ClassCastException {
        return (ModelsTxRegisterKey)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxSendTokens`. If the actual instance is not `ModelsTxSendTokens`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxSendTokens`
     * @throws ClassCastException if the instance is not `ModelsTxSendTokens`
     */
    public ModelsTxSendTokens getModelsTxSendTokens() throws ClassCastException {
        return (ModelsTxSendTokens)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxSetTransactionCosts`. If the actual instance is not `ModelsTxSetTransactionCosts`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxSetTransactionCosts`
     * @throws ClassCastException if the instance is not `ModelsTxSetTransactionCosts`
     */
    public ModelsTxSetTransactionCosts getModelsTxSetTransactionCosts() throws ClassCastException {
        return (ModelsTxSetTransactionCosts)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxSetAccount`. If the actual instance is not `ModelsTxSetAccount`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxSetAccount`
     * @throws ClassCastException if the instance is not `ModelsTxSetAccount`
     */
    public ModelsTxSetAccount getModelsTxSetAccount() throws ClassCastException {
        return (ModelsTxSetAccount)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxCollectFaucet`. If the actual instance is not `ModelsTxCollectFaucet`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxCollectFaucet`
     * @throws ClassCastException if the instance is not `ModelsTxCollectFaucet`
     */
    public ModelsTxCollectFaucet getModelsTxCollectFaucet() throws ClassCastException {
        return (ModelsTxCollectFaucet)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ModelsTxSetKeykeeper`. If the actual instance is not `ModelsTxSetKeykeeper`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ModelsTxSetKeykeeper`
     * @throws ClassCastException if the instance is not `ModelsTxSetKeykeeper`
     */
    public ModelsTxSetKeykeeper getModelsTxSetKeykeeper() throws ClassCastException {
        return (ModelsTxSetKeykeeper)super.getActualInstance();
    }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ApiGenericTransactionWithInfoTx
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with ModelsTxVote
    try {
      ModelsTxVote.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxVote failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxAdmin
    try {
      ModelsTxAdmin.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxAdmin failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxSetProcess
    try {
      ModelsTxSetProcess.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxSetProcess failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxRegisterKey
    try {
      ModelsTxRegisterKey.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxRegisterKey failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxSendTokens
    try {
      ModelsTxSendTokens.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxSendTokens failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxSetTransactionCosts
    try {
      ModelsTxSetTransactionCosts.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxSetTransactionCosts failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxSetAccount
    try {
      ModelsTxSetAccount.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxSetAccount failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxCollectFaucet
    try {
      ModelsTxCollectFaucet.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxCollectFaucet failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with ModelsTxSetKeykeeper
    try {
      ModelsTxSetKeykeeper.validateJsonElement(jsonElement);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for ModelsTxSetKeykeeper failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for ApiGenericTransactionWithInfoTx with oneOf schemas: ModelsTxAdmin, ModelsTxCollectFaucet, ModelsTxRegisterKey, ModelsTxSendTokens, ModelsTxSetAccount, ModelsTxSetKeykeeper, ModelsTxSetProcess, ModelsTxSetTransactionCosts, ModelsTxVote. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
    }
  }

 /**
  * Create an instance of ApiGenericTransactionWithInfoTx given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ApiGenericTransactionWithInfoTx
  * @throws IOException if the JSON string is invalid with respect to ApiGenericTransactionWithInfoTx
  */
  public static ApiGenericTransactionWithInfoTx fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiGenericTransactionWithInfoTx.class);
  }

 /**
  * Convert an instance of ApiGenericTransactionWithInfoTx to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

