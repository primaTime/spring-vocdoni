/*
 * Vocdoni API
 * The Vocdoni API is a REST API that substitutes the previous RPCs in order to make it easier for  developers/integrators to build on top of the voting protocol. This API facilitates creating votings using Vocdoni, without the hassle of learning a complex blockchain platform, allowing to perform all the features that enable the voting protocol such as creating an account, entity, voting process, census & vote, abstracting as much as possible the complexity and offering simple and straightforward methods to perform those actions.   You can review the API endpoints documentation in this section, the main entities are:  - [**Chain**](chain): The Vocdoni blockchain is named Vochain. It is a Byzantine fault-tolerant network based on Tendermint that executes the Vocdoni Protocol logic represented as a state machine. Its main purpose is to register votes in a  decentralized and verifiable format. In those endpoints, you can consult the state of the chain, transactions costs,  list organizations and get more Vochain info. - [**Accounts**](accounts): Identified by an Ethereum like address. An account can create and manage elections, transfer tokens, give power to other accounts on his behalf (delegates) and manage its metadata. - [**Elections**](elections): Is a rule-set of options and requirements for creating a process in which people vote a series of options. To know more about the params of an election and its lifecycle go [here](../get-started/intro#23-elections). In this section you will find all information related to an election as its information, election keys, submitted votes & how to create a new election. - [**Censuses**](censuses): The census is a key component of any voting process. It specifies the set of users (identified by a public key or address) eligible for participating in an election. To understand more about the Censuses you can check [here](../get-started/intro#21-the-census). Here you will be able to get censuses information like the Merkle root, total weight & size, import/export the censuses and create new ones. - [**Votes**](votes): All the information related to the vote issued by a participant in a vote, you can check the validity of the vote, consult your information and send a vote. - [**SIK**](sik): The Secret Identity Key is a user-generated piece of information that proves the user's identity without revealing it. It is the hash of the user's address, the signature of a public message and an optional secret part. It is used to ensure anonymous voting. All registered accounts or anonymous voters must register a SIK, and they are all stored in a Merkle tree. The `/siks` endpoints help to generate a proof of membership, get the current valid SIK roots, or check if an account has a valid SIK.   ### Errors   Backend error messages list are defined here: https://github.com/vocdoni/vocdoni-node/blob/master/api/errors.go  About the **204 no content** error: this message will be returned only if the asset being queried cannot be found but no other errors have occurred. This response is commonly used to prevent Javascript errors that may arise when a client is waiting for a  transaction to be published. During this waiting period, the client can repeatedly query the endpoint until a  successful response with a status code of 200 is received, thereby avoiding any errors that may occur due to the transaction not being published yet.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.vocdoni.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.vocdoni.model.ModelsCensusOrigin;
import io.vocdoni.model.ModelsEnvelopeType;
import io.vocdoni.model.ModelsProcessMode;
import io.vocdoni.model.ModelsProcessResult;
import io.vocdoni.model.ModelsProcessStatus;
import io.vocdoni.model.ModelsProcessVoteOptions;
import io.vocdoni.model.ModelsSourceNetworkId;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.vocdoni.invoker.JSON;

/**
 * ModelsProcess
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-02-09T17:09:26.351036+01:00[Europe/Prague]")
public class ModelsProcess {
  public static final String SERIALIZED_NAME_BLOCK_COUNT = "blockCount";
  @SerializedName(SERIALIZED_NAME_BLOCK_COUNT)
  private Integer blockCount;

  public static final String SERIALIZED_NAME_CENSUS_ORIGIN = "censusOrigin";
  @SerializedName(SERIALIZED_NAME_CENSUS_ORIGIN)
  private ModelsCensusOrigin censusOrigin;

  public static final String SERIALIZED_NAME_CENSUS_ROOT = "censusRoot";
  @SerializedName(SERIALIZED_NAME_CENSUS_ROOT)
  private List<Integer> censusRoot;

  public static final String SERIALIZED_NAME_CENSUS_U_R_I = "censusURI";
  @SerializedName(SERIALIZED_NAME_CENSUS_U_R_I)
  private String censusURI;

  public static final String SERIALIZED_NAME_ENCRYPTION_PRIVATE_KEYS = "encryptionPrivateKeys";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_PRIVATE_KEYS)
  private List<String> encryptionPrivateKeys;

  public static final String SERIALIZED_NAME_ENCRYPTION_PUBLIC_KEYS = "encryptionPublicKeys";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_PUBLIC_KEYS)
  private List<String> encryptionPublicKeys;

  public static final String SERIALIZED_NAME_ENTITY_ID = "entityId";
  @SerializedName(SERIALIZED_NAME_ENTITY_ID)
  private List<Integer> entityId;

  public static final String SERIALIZED_NAME_ENVELOPE_TYPE = "envelopeType";
  @SerializedName(SERIALIZED_NAME_ENVELOPE_TYPE)
  private ModelsEnvelopeType envelopeType;

  public static final String SERIALIZED_NAME_ETH_INDEX_SLOT = "ethIndexSlot";
  @SerializedName(SERIALIZED_NAME_ETH_INDEX_SLOT)
  private Integer ethIndexSlot;

  public static final String SERIALIZED_NAME_KEY_INDEX = "keyIndex";
  @SerializedName(SERIALIZED_NAME_KEY_INDEX)
  private Integer keyIndex;

  public static final String SERIALIZED_NAME_MAX_CENSUS_SIZE = "maxCensusSize";
  @SerializedName(SERIALIZED_NAME_MAX_CENSUS_SIZE)
  private Integer maxCensusSize;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private String metadata;

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private ModelsProcessMode mode;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private Integer namespace;

  public static final String SERIALIZED_NAME_NULLIFIERS_ROOT = "nullifiersRoot";
  @SerializedName(SERIALIZED_NAME_NULLIFIERS_ROOT)
  private List<Integer> nullifiersRoot;

  public static final String SERIALIZED_NAME_OWNER = "owner";
  @SerializedName(SERIALIZED_NAME_OWNER)
  private List<Integer> owner;

  public static final String SERIALIZED_NAME_PARAMS_SIGNATURE = "paramsSignature";
  @SerializedName(SERIALIZED_NAME_PARAMS_SIGNATURE)
  private List<Integer> paramsSignature;

  public static final String SERIALIZED_NAME_PROCESS_ID = "processId";
  @SerializedName(SERIALIZED_NAME_PROCESS_ID)
  private List<Integer> processId;

  public static final String SERIALIZED_NAME_QUESTION_COUNT = "questionCount";
  @SerializedName(SERIALIZED_NAME_QUESTION_COUNT)
  private Integer questionCount;

  public static final String SERIALIZED_NAME_QUESTION_INDEX = "questionIndex";
  @SerializedName(SERIALIZED_NAME_QUESTION_INDEX)
  private Integer questionIndex;

  public static final String SERIALIZED_NAME_RESULTS = "results";
  @SerializedName(SERIALIZED_NAME_RESULTS)
  private ModelsProcessResult results;

  public static final String SERIALIZED_NAME_ROLLING_CENSUS_ROOT = "rollingCensusRoot";
  @SerializedName(SERIALIZED_NAME_ROLLING_CENSUS_ROOT)
  private List<Integer> rollingCensusRoot;

  public static final String SERIALIZED_NAME_ROLLING_CENSUS_SIZE = "rollingCensusSize";
  @SerializedName(SERIALIZED_NAME_ROLLING_CENSUS_SIZE)
  private Integer rollingCensusSize;

  public static final String SERIALIZED_NAME_SOURCE_BLOCK_HEIGHT = "sourceBlockHeight";
  @SerializedName(SERIALIZED_NAME_SOURCE_BLOCK_HEIGHT)
  private Integer sourceBlockHeight;

  public static final String SERIALIZED_NAME_SOURCE_NETWORK_CONTRACT_ADDR = "sourceNetworkContractAddr";
  @SerializedName(SERIALIZED_NAME_SOURCE_NETWORK_CONTRACT_ADDR)
  private List<Integer> sourceNetworkContractAddr;

  public static final String SERIALIZED_NAME_SOURCE_NETWORK_ID = "sourceNetworkId";
  @SerializedName(SERIALIZED_NAME_SOURCE_NETWORK_ID)
  private ModelsSourceNetworkId sourceNetworkId;

  public static final String SERIALIZED_NAME_START_BLOCK = "startBlock";
  @SerializedName(SERIALIZED_NAME_START_BLOCK)
  private Integer startBlock;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private ModelsProcessStatus status;

  public static final String SERIALIZED_NAME_TEMP_S_I_KS = "tempSIKs";
  @SerializedName(SERIALIZED_NAME_TEMP_S_I_KS)
  private Boolean tempSIKs;

  public static final String SERIALIZED_NAME_TOKEN_DECIMALS = "tokenDecimals";
  @SerializedName(SERIALIZED_NAME_TOKEN_DECIMALS)
  private Integer tokenDecimals;

  public static final String SERIALIZED_NAME_VOTE_OPTIONS = "voteOptions";
  @SerializedName(SERIALIZED_NAME_VOTE_OPTIONS)
  private ModelsProcessVoteOptions voteOptions;

  public ModelsProcess() {
  }

  public ModelsProcess blockCount(Integer blockCount) {
    
    this.blockCount = blockCount;
    return this;
  }

   /**
   * BlockCount represents the amount of tendermint blocks that the process will last
   * @return blockCount
  **/
  @javax.annotation.Nullable
  public Integer getBlockCount() {
    return blockCount;
  }


  public void setBlockCount(Integer blockCount) {
    this.blockCount = blockCount;
  }


  public ModelsProcess censusOrigin(ModelsCensusOrigin censusOrigin) {
    
    this.censusOrigin = censusOrigin;
    return this;
  }

   /**
   * Get censusOrigin
   * @return censusOrigin
  **/
  @javax.annotation.Nullable
  public ModelsCensusOrigin getCensusOrigin() {
    return censusOrigin;
  }


  public void setCensusOrigin(ModelsCensusOrigin censusOrigin) {
    this.censusOrigin = censusOrigin;
  }


  public ModelsProcess censusRoot(List<Integer> censusRoot) {
    
    this.censusRoot = censusRoot;
    return this;
  }

  public ModelsProcess addCensusRootItem(Integer censusRootItem) {
    if (this.censusRoot == null) {
      this.censusRoot = new ArrayList<>();
    }
    this.censusRoot.add(censusRootItem);
    return this;
  }

   /**
   * CensusRoot merkle root of all the census in the process
   * @return censusRoot
  **/
  @javax.annotation.Nullable
  public List<Integer> getCensusRoot() {
    return censusRoot;
  }


  public void setCensusRoot(List<Integer> censusRoot) {
    this.censusRoot = censusRoot;
  }


  public ModelsProcess censusURI(String censusURI) {
    
    this.censusURI = censusURI;
    return this;
  }

   /**
   * CensusURI where to find the census
   * @return censusURI
  **/
  @javax.annotation.Nullable
  public String getCensusURI() {
    return censusURI;
  }


  public void setCensusURI(String censusURI) {
    this.censusURI = censusURI;
  }


  public ModelsProcess encryptionPrivateKeys(List<String> encryptionPrivateKeys) {
    
    this.encryptionPrivateKeys = encryptionPrivateKeys;
    return this;
  }

  public ModelsProcess addEncryptionPrivateKeysItem(String encryptionPrivateKeysItem) {
    if (this.encryptionPrivateKeys == null) {
      this.encryptionPrivateKeys = new ArrayList<>();
    }
    this.encryptionPrivateKeys.add(encryptionPrivateKeysItem);
    return this;
  }

   /**
   * EncryptionPrivateKeys are the keys required to decrypt the votes
   * @return encryptionPrivateKeys
  **/
  @javax.annotation.Nullable
  public List<String> getEncryptionPrivateKeys() {
    return encryptionPrivateKeys;
  }


  public void setEncryptionPrivateKeys(List<String> encryptionPrivateKeys) {
    this.encryptionPrivateKeys = encryptionPrivateKeys;
  }


  public ModelsProcess encryptionPublicKeys(List<String> encryptionPublicKeys) {
    
    this.encryptionPublicKeys = encryptionPublicKeys;
    return this;
  }

  public ModelsProcess addEncryptionPublicKeysItem(String encryptionPublicKeysItem) {
    if (this.encryptionPublicKeys == null) {
      this.encryptionPublicKeys = new ArrayList<>();
    }
    this.encryptionPublicKeys.add(encryptionPublicKeysItem);
    return this;
  }

   /**
   * EncryptionPublicKeys are the keys required to encrypt the votes
   * @return encryptionPublicKeys
  **/
  @javax.annotation.Nullable
  public List<String> getEncryptionPublicKeys() {
    return encryptionPublicKeys;
  }


  public void setEncryptionPublicKeys(List<String> encryptionPublicKeys) {
    this.encryptionPublicKeys = encryptionPublicKeys;
  }


  public ModelsProcess entityId(List<Integer> entityId) {
    
    this.entityId = entityId;
    return this;
  }

  public ModelsProcess addEntityIdItem(Integer entityIdItem) {
    if (this.entityId == null) {
      this.entityId = new ArrayList<>();
    }
    this.entityId.add(entityIdItem);
    return this;
  }

   /**
   * EntityId identifies unequivocally an entity
   * @return entityId
  **/
  @javax.annotation.Nullable
  public List<Integer> getEntityId() {
    return entityId;
  }


  public void setEntityId(List<Integer> entityId) {
    this.entityId = entityId;
  }


  public ModelsProcess envelopeType(ModelsEnvelopeType envelopeType) {
    
    this.envelopeType = envelopeType;
    return this;
  }

   /**
   * Get envelopeType
   * @return envelopeType
  **/
  @javax.annotation.Nullable
  public ModelsEnvelopeType getEnvelopeType() {
    return envelopeType;
  }


  public void setEnvelopeType(ModelsEnvelopeType envelopeType) {
    this.envelopeType = envelopeType;
  }


  public ModelsProcess ethIndexSlot(Integer ethIndexSlot) {
    
    this.ethIndexSlot = ethIndexSlot;
    return this;
  }

   /**
   * Get ethIndexSlot
   * @return ethIndexSlot
  **/
  @javax.annotation.Nullable
  public Integer getEthIndexSlot() {
    return ethIndexSlot;
  }


  public void setEthIndexSlot(Integer ethIndexSlot) {
    this.ethIndexSlot = ethIndexSlot;
  }


  public ModelsProcess keyIndex(Integer keyIndex) {
    
    this.keyIndex = keyIndex;
    return this;
  }

   /**
   * Get keyIndex
   * @return keyIndex
  **/
  @javax.annotation.Nullable
  public Integer getKeyIndex() {
    return keyIndex;
  }


  public void setKeyIndex(Integer keyIndex) {
    this.keyIndex = keyIndex;
  }


  public ModelsProcess maxCensusSize(Integer maxCensusSize) {
    
    this.maxCensusSize = maxCensusSize;
    return this;
  }

   /**
   * MaxCensusSize is set by the Process creator, indicates the maximum number of votes that will be allowed.
   * @return maxCensusSize
  **/
  @javax.annotation.Nullable
  public Integer getMaxCensusSize() {
    return maxCensusSize;
  }


  public void setMaxCensusSize(Integer maxCensusSize) {
    this.maxCensusSize = maxCensusSize;
  }


  public ModelsProcess metadata(String metadata) {
    
    this.metadata = metadata;
    return this;
  }

   /**
   * Metadata is the content hashed URI of the JSON meta data (See Data Origins)
   * @return metadata
  **/
  @javax.annotation.Nullable
  public String getMetadata() {
    return metadata;
  }


  public void setMetadata(String metadata) {
    this.metadata = metadata;
  }


  public ModelsProcess mode(ModelsProcessMode mode) {
    
    this.mode = mode;
    return this;
  }

   /**
   * Get mode
   * @return mode
  **/
  @javax.annotation.Nullable
  public ModelsProcessMode getMode() {
    return mode;
  }


  public void setMode(ModelsProcessMode mode) {
    this.mode = mode;
  }


  public ModelsProcess namespace(Integer namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * Get namespace
   * @return namespace
  **/
  @javax.annotation.Nullable
  public Integer getNamespace() {
    return namespace;
  }


  public void setNamespace(Integer namespace) {
    this.namespace = namespace;
  }


  public ModelsProcess nullifiersRoot(List<Integer> nullifiersRoot) {
    
    this.nullifiersRoot = nullifiersRoot;
    return this;
  }

  public ModelsProcess addNullifiersRootItem(Integer nullifiersRootItem) {
    if (this.nullifiersRoot == null) {
      this.nullifiersRoot = new ArrayList<>();
    }
    this.nullifiersRoot.add(nullifiersRootItem);
    return this;
  }

   /**
   * NullifiersRoot is the root of the pre-census nullifiers merkle tree. Used when Mode.PreRegister &#x3D; true.
   * @return nullifiersRoot
  **/
  @javax.annotation.Nullable
  public List<Integer> getNullifiersRoot() {
    return nullifiersRoot;
  }


  public void setNullifiersRoot(List<Integer> nullifiersRoot) {
    this.nullifiersRoot = nullifiersRoot;
  }


  public ModelsProcess owner(List<Integer> owner) {
    
    this.owner = owner;
    return this;
  }

  public ModelsProcess addOwnerItem(Integer ownerItem) {
    if (this.owner == null) {
      this.owner = new ArrayList<>();
    }
    this.owner.add(ownerItem);
    return this;
  }

   /**
   * Owner is the creator of a process (if any) otherwise is assumed the creator is the entityId
   * @return owner
  **/
  @javax.annotation.Nullable
  public List<Integer> getOwner() {
    return owner;
  }


  public void setOwner(List<Integer> owner) {
    this.owner = owner;
  }


  public ModelsProcess paramsSignature(List<Integer> paramsSignature) {
    
    this.paramsSignature = paramsSignature;
    return this;
  }

  public ModelsProcess addParamsSignatureItem(Integer paramsSignatureItem) {
    if (this.paramsSignature == null) {
      this.paramsSignature = new ArrayList<>();
    }
    this.paramsSignature.add(paramsSignatureItem);
    return this;
  }

   /**
   * Get paramsSignature
   * @return paramsSignature
  **/
  @javax.annotation.Nullable
  public List<Integer> getParamsSignature() {
    return paramsSignature;
  }


  public void setParamsSignature(List<Integer> paramsSignature) {
    this.paramsSignature = paramsSignature;
  }


  public ModelsProcess processId(List<Integer> processId) {
    
    this.processId = processId;
    return this;
  }

  public ModelsProcess addProcessIdItem(Integer processIdItem) {
    if (this.processId == null) {
      this.processId = new ArrayList<>();
    }
    this.processId.add(processIdItem);
    return this;
  }

   /**
   * Get processId
   * @return processId
  **/
  @javax.annotation.Nullable
  public List<Integer> getProcessId() {
    return processId;
  }


  public void setProcessId(List<Integer> processId) {
    this.processId = processId;
  }


  public ModelsProcess questionCount(Integer questionCount) {
    
    this.questionCount = questionCount;
    return this;
  }

   /**
   * Get questionCount
   * @return questionCount
  **/
  @javax.annotation.Nullable
  public Integer getQuestionCount() {
    return questionCount;
  }


  public void setQuestionCount(Integer questionCount) {
    this.questionCount = questionCount;
  }


  public ModelsProcess questionIndex(Integer questionIndex) {
    
    this.questionIndex = questionIndex;
    return this;
  }

   /**
   * Get questionIndex
   * @return questionIndex
  **/
  @javax.annotation.Nullable
  public Integer getQuestionIndex() {
    return questionIndex;
  }


  public void setQuestionIndex(Integer questionIndex) {
    this.questionIndex = questionIndex;
  }


  public ModelsProcess results(ModelsProcessResult results) {
    
    this.results = results;
    return this;
  }

   /**
   * Get results
   * @return results
  **/
  @javax.annotation.Nullable
  public ModelsProcessResult getResults() {
    return results;
  }


  public void setResults(ModelsProcessResult results) {
    this.results = results;
  }


  public ModelsProcess rollingCensusRoot(List<Integer> rollingCensusRoot) {
    
    this.rollingCensusRoot = rollingCensusRoot;
    return this;
  }

  public ModelsProcess addRollingCensusRootItem(Integer rollingCensusRootItem) {
    if (this.rollingCensusRoot == null) {
      this.rollingCensusRoot = new ArrayList<>();
    }
    this.rollingCensusRoot.add(rollingCensusRootItem);
    return this;
  }

   /**
   * RollingCensusRoot merkle root of the rolling census.  Set by the vocdoni-node when Mode.Process &#x3D; true
   * @return rollingCensusRoot
  **/
  @javax.annotation.Nullable
  public List<Integer> getRollingCensusRoot() {
    return rollingCensusRoot;
  }


  public void setRollingCensusRoot(List<Integer> rollingCensusRoot) {
    this.rollingCensusRoot = rollingCensusRoot;
  }


  public ModelsProcess rollingCensusSize(Integer rollingCensusSize) {
    
    this.rollingCensusSize = rollingCensusSize;
    return this;
  }

   /**
   * RollingCensusSize is set by the vocdoni-node when Mode.PreRegister &#x3D; true and the StartBlock has been reached.
   * @return rollingCensusSize
  **/
  @javax.annotation.Nullable
  public Integer getRollingCensusSize() {
    return rollingCensusSize;
  }


  public void setRollingCensusSize(Integer rollingCensusSize) {
    this.rollingCensusSize = rollingCensusSize;
  }


  public ModelsProcess sourceBlockHeight(Integer sourceBlockHeight) {
    
    this.sourceBlockHeight = sourceBlockHeight;
    return this;
  }

   /**
   * SourceBlockHeight is the block height of the origin blockchain (if any)
   * @return sourceBlockHeight
  **/
  @javax.annotation.Nullable
  public Integer getSourceBlockHeight() {
    return sourceBlockHeight;
  }


  public void setSourceBlockHeight(Integer sourceBlockHeight) {
    this.sourceBlockHeight = sourceBlockHeight;
  }


  public ModelsProcess sourceNetworkContractAddr(List<Integer> sourceNetworkContractAddr) {
    
    this.sourceNetworkContractAddr = sourceNetworkContractAddr;
    return this;
  }

  public ModelsProcess addSourceNetworkContractAddrItem(Integer sourceNetworkContractAddrItem) {
    if (this.sourceNetworkContractAddr == null) {
      this.sourceNetworkContractAddr = new ArrayList<>();
    }
    this.sourceNetworkContractAddr.add(sourceNetworkContractAddrItem);
    return this;
  }

   /**
   * sourceNetworkContractAddr is used for EVM token based voting and it is the contract address of the token that is going to define the census
   * @return sourceNetworkContractAddr
  **/
  @javax.annotation.Nullable
  public List<Integer> getSourceNetworkContractAddr() {
    return sourceNetworkContractAddr;
  }


  public void setSourceNetworkContractAddr(List<Integer> sourceNetworkContractAddr) {
    this.sourceNetworkContractAddr = sourceNetworkContractAddr;
  }


  public ModelsProcess sourceNetworkId(ModelsSourceNetworkId sourceNetworkId) {
    
    this.sourceNetworkId = sourceNetworkId;
    return this;
  }

   /**
   * Get sourceNetworkId
   * @return sourceNetworkId
  **/
  @javax.annotation.Nullable
  public ModelsSourceNetworkId getSourceNetworkId() {
    return sourceNetworkId;
  }


  public void setSourceNetworkId(ModelsSourceNetworkId sourceNetworkId) {
    this.sourceNetworkId = sourceNetworkId;
  }


  public ModelsProcess startBlock(Integer startBlock) {
    
    this.startBlock = startBlock;
    return this;
  }

   /**
   * StartBlock represents the tendermint block where the process goes from scheduled to active
   * @return startBlock
  **/
  @javax.annotation.Nullable
  public Integer getStartBlock() {
    return startBlock;
  }


  public void setStartBlock(Integer startBlock) {
    this.startBlock = startBlock;
  }


  public ModelsProcess status(ModelsProcessStatus status) {
    
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nullable
  public ModelsProcessStatus getStatus() {
    return status;
  }


  public void setStatus(ModelsProcessStatus status) {
    this.status = status;
  }


  public ModelsProcess tempSIKs(Boolean tempSIKs) {
    
    this.tempSIKs = tempSIKs;
    return this;
  }

   /**
   * tempSIKs flag decides if when the process has finished, the SIKs related to it will be removed or not
   * @return tempSIKs
  **/
  @javax.annotation.Nullable
  public Boolean getTempSIKs() {
    return tempSIKs;
  }


  public void setTempSIKs(Boolean tempSIKs) {
    this.tempSIKs = tempSIKs;
  }


  public ModelsProcess tokenDecimals(Integer tokenDecimals) {
    
    this.tokenDecimals = tokenDecimals;
    return this;
  }

   /**
   * tokenDecimals represents the number of decimals of the token (i.e ERC20) used for voting. It is normally used for processes with on-chain census
   * @return tokenDecimals
  **/
  @javax.annotation.Nullable
  public Integer getTokenDecimals() {
    return tokenDecimals;
  }


  public void setTokenDecimals(Integer tokenDecimals) {
    this.tokenDecimals = tokenDecimals;
  }


  public ModelsProcess voteOptions(ModelsProcessVoteOptions voteOptions) {
    
    this.voteOptions = voteOptions;
    return this;
  }

   /**
   * Get voteOptions
   * @return voteOptions
  **/
  @javax.annotation.Nullable
  public ModelsProcessVoteOptions getVoteOptions() {
    return voteOptions;
  }


  public void setVoteOptions(ModelsProcessVoteOptions voteOptions) {
    this.voteOptions = voteOptions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelsProcess modelsProcess = (ModelsProcess) o;
    return Objects.equals(this.blockCount, modelsProcess.blockCount) &&
        Objects.equals(this.censusOrigin, modelsProcess.censusOrigin) &&
        Objects.equals(this.censusRoot, modelsProcess.censusRoot) &&
        Objects.equals(this.censusURI, modelsProcess.censusURI) &&
        Objects.equals(this.encryptionPrivateKeys, modelsProcess.encryptionPrivateKeys) &&
        Objects.equals(this.encryptionPublicKeys, modelsProcess.encryptionPublicKeys) &&
        Objects.equals(this.entityId, modelsProcess.entityId) &&
        Objects.equals(this.envelopeType, modelsProcess.envelopeType) &&
        Objects.equals(this.ethIndexSlot, modelsProcess.ethIndexSlot) &&
        Objects.equals(this.keyIndex, modelsProcess.keyIndex) &&
        Objects.equals(this.maxCensusSize, modelsProcess.maxCensusSize) &&
        Objects.equals(this.metadata, modelsProcess.metadata) &&
        Objects.equals(this.mode, modelsProcess.mode) &&
        Objects.equals(this.namespace, modelsProcess.namespace) &&
        Objects.equals(this.nullifiersRoot, modelsProcess.nullifiersRoot) &&
        Objects.equals(this.owner, modelsProcess.owner) &&
        Objects.equals(this.paramsSignature, modelsProcess.paramsSignature) &&
        Objects.equals(this.processId, modelsProcess.processId) &&
        Objects.equals(this.questionCount, modelsProcess.questionCount) &&
        Objects.equals(this.questionIndex, modelsProcess.questionIndex) &&
        Objects.equals(this.results, modelsProcess.results) &&
        Objects.equals(this.rollingCensusRoot, modelsProcess.rollingCensusRoot) &&
        Objects.equals(this.rollingCensusSize, modelsProcess.rollingCensusSize) &&
        Objects.equals(this.sourceBlockHeight, modelsProcess.sourceBlockHeight) &&
        Objects.equals(this.sourceNetworkContractAddr, modelsProcess.sourceNetworkContractAddr) &&
        Objects.equals(this.sourceNetworkId, modelsProcess.sourceNetworkId) &&
        Objects.equals(this.startBlock, modelsProcess.startBlock) &&
        Objects.equals(this.status, modelsProcess.status) &&
        Objects.equals(this.tempSIKs, modelsProcess.tempSIKs) &&
        Objects.equals(this.tokenDecimals, modelsProcess.tokenDecimals) &&
        Objects.equals(this.voteOptions, modelsProcess.voteOptions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blockCount, censusOrigin, censusRoot, censusURI, encryptionPrivateKeys, encryptionPublicKeys, entityId, envelopeType, ethIndexSlot, keyIndex, maxCensusSize, metadata, mode, namespace, nullifiersRoot, owner, paramsSignature, processId, questionCount, questionIndex, results, rollingCensusRoot, rollingCensusSize, sourceBlockHeight, sourceNetworkContractAddr, sourceNetworkId, startBlock, status, tempSIKs, tokenDecimals, voteOptions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ModelsProcess {\n");
    sb.append("    blockCount: ").append(toIndentedString(blockCount)).append("\n");
    sb.append("    censusOrigin: ").append(toIndentedString(censusOrigin)).append("\n");
    sb.append("    censusRoot: ").append(toIndentedString(censusRoot)).append("\n");
    sb.append("    censusURI: ").append(toIndentedString(censusURI)).append("\n");
    sb.append("    encryptionPrivateKeys: ").append(toIndentedString(encryptionPrivateKeys)).append("\n");
    sb.append("    encryptionPublicKeys: ").append(toIndentedString(encryptionPublicKeys)).append("\n");
    sb.append("    entityId: ").append(toIndentedString(entityId)).append("\n");
    sb.append("    envelopeType: ").append(toIndentedString(envelopeType)).append("\n");
    sb.append("    ethIndexSlot: ").append(toIndentedString(ethIndexSlot)).append("\n");
    sb.append("    keyIndex: ").append(toIndentedString(keyIndex)).append("\n");
    sb.append("    maxCensusSize: ").append(toIndentedString(maxCensusSize)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    nullifiersRoot: ").append(toIndentedString(nullifiersRoot)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    paramsSignature: ").append(toIndentedString(paramsSignature)).append("\n");
    sb.append("    processId: ").append(toIndentedString(processId)).append("\n");
    sb.append("    questionCount: ").append(toIndentedString(questionCount)).append("\n");
    sb.append("    questionIndex: ").append(toIndentedString(questionIndex)).append("\n");
    sb.append("    results: ").append(toIndentedString(results)).append("\n");
    sb.append("    rollingCensusRoot: ").append(toIndentedString(rollingCensusRoot)).append("\n");
    sb.append("    rollingCensusSize: ").append(toIndentedString(rollingCensusSize)).append("\n");
    sb.append("    sourceBlockHeight: ").append(toIndentedString(sourceBlockHeight)).append("\n");
    sb.append("    sourceNetworkContractAddr: ").append(toIndentedString(sourceNetworkContractAddr)).append("\n");
    sb.append("    sourceNetworkId: ").append(toIndentedString(sourceNetworkId)).append("\n");
    sb.append("    startBlock: ").append(toIndentedString(startBlock)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    tempSIKs: ").append(toIndentedString(tempSIKs)).append("\n");
    sb.append("    tokenDecimals: ").append(toIndentedString(tokenDecimals)).append("\n");
    sb.append("    voteOptions: ").append(toIndentedString(voteOptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("blockCount");
    openapiFields.add("censusOrigin");
    openapiFields.add("censusRoot");
    openapiFields.add("censusURI");
    openapiFields.add("encryptionPrivateKeys");
    openapiFields.add("encryptionPublicKeys");
    openapiFields.add("entityId");
    openapiFields.add("envelopeType");
    openapiFields.add("ethIndexSlot");
    openapiFields.add("keyIndex");
    openapiFields.add("maxCensusSize");
    openapiFields.add("metadata");
    openapiFields.add("mode");
    openapiFields.add("namespace");
    openapiFields.add("nullifiersRoot");
    openapiFields.add("owner");
    openapiFields.add("paramsSignature");
    openapiFields.add("processId");
    openapiFields.add("questionCount");
    openapiFields.add("questionIndex");
    openapiFields.add("results");
    openapiFields.add("rollingCensusRoot");
    openapiFields.add("rollingCensusSize");
    openapiFields.add("sourceBlockHeight");
    openapiFields.add("sourceNetworkContractAddr");
    openapiFields.add("sourceNetworkId");
    openapiFields.add("startBlock");
    openapiFields.add("status");
    openapiFields.add("tempSIKs");
    openapiFields.add("tokenDecimals");
    openapiFields.add("voteOptions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ModelsProcess
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ModelsProcess.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ModelsProcess is not found in the empty JSON string", ModelsProcess.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ModelsProcess.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ModelsProcess` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("censusRoot") != null && !jsonObj.get("censusRoot").isJsonNull() && !jsonObj.get("censusRoot").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `censusRoot` to be an array in the JSON string but got `%s`", jsonObj.get("censusRoot").toString()));
      }
      if ((jsonObj.get("censusURI") != null && !jsonObj.get("censusURI").isJsonNull()) && !jsonObj.get("censusURI").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `censusURI` to be a primitive type in the JSON string but got `%s`", jsonObj.get("censusURI").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("encryptionPrivateKeys") != null && !jsonObj.get("encryptionPrivateKeys").isJsonNull() && !jsonObj.get("encryptionPrivateKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptionPrivateKeys` to be an array in the JSON string but got `%s`", jsonObj.get("encryptionPrivateKeys").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("encryptionPublicKeys") != null && !jsonObj.get("encryptionPublicKeys").isJsonNull() && !jsonObj.get("encryptionPublicKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptionPublicKeys` to be an array in the JSON string but got `%s`", jsonObj.get("encryptionPublicKeys").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("entityId") != null && !jsonObj.get("entityId").isJsonNull() && !jsonObj.get("entityId").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `entityId` to be an array in the JSON string but got `%s`", jsonObj.get("entityId").toString()));
      }
      // validate the optional field `envelopeType`
      if (jsonObj.get("envelopeType") != null && !jsonObj.get("envelopeType").isJsonNull()) {
        ModelsEnvelopeType.validateJsonElement(jsonObj.get("envelopeType"));
      }
      if ((jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) && !jsonObj.get("metadata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
      }
      // validate the optional field `mode`
      if (jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) {
        ModelsProcessMode.validateJsonElement(jsonObj.get("mode"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("nullifiersRoot") != null && !jsonObj.get("nullifiersRoot").isJsonNull() && !jsonObj.get("nullifiersRoot").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `nullifiersRoot` to be an array in the JSON string but got `%s`", jsonObj.get("nullifiersRoot").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("owner") != null && !jsonObj.get("owner").isJsonNull() && !jsonObj.get("owner").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `owner` to be an array in the JSON string but got `%s`", jsonObj.get("owner").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("paramsSignature") != null && !jsonObj.get("paramsSignature").isJsonNull() && !jsonObj.get("paramsSignature").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `paramsSignature` to be an array in the JSON string but got `%s`", jsonObj.get("paramsSignature").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("processId") != null && !jsonObj.get("processId").isJsonNull() && !jsonObj.get("processId").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `processId` to be an array in the JSON string but got `%s`", jsonObj.get("processId").toString()));
      }
      // validate the optional field `results`
      if (jsonObj.get("results") != null && !jsonObj.get("results").isJsonNull()) {
        ModelsProcessResult.validateJsonElement(jsonObj.get("results"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("rollingCensusRoot") != null && !jsonObj.get("rollingCensusRoot").isJsonNull() && !jsonObj.get("rollingCensusRoot").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `rollingCensusRoot` to be an array in the JSON string but got `%s`", jsonObj.get("rollingCensusRoot").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sourceNetworkContractAddr") != null && !jsonObj.get("sourceNetworkContractAddr").isJsonNull() && !jsonObj.get("sourceNetworkContractAddr").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceNetworkContractAddr` to be an array in the JSON string but got `%s`", jsonObj.get("sourceNetworkContractAddr").toString()));
      }
      // validate the optional field `voteOptions`
      if (jsonObj.get("voteOptions") != null && !jsonObj.get("voteOptions").isJsonNull()) {
        ModelsProcessVoteOptions.validateJsonElement(jsonObj.get("voteOptions"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ModelsProcess.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ModelsProcess' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ModelsProcess> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ModelsProcess.class));

       return (TypeAdapter<T>) new TypeAdapter<ModelsProcess>() {
           @Override
           public void write(JsonWriter out, ModelsProcess value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ModelsProcess read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ModelsProcess given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ModelsProcess
  * @throws IOException if the JSON string is invalid with respect to ModelsProcess
  */
  public static ModelsProcess fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ModelsProcess.class);
  }

 /**
  * Convert an instance of ModelsProcess to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

