/*
 * Vocdoni API
 * The Vocdoni API is a REST API that substitutes the previous RPCs in order to make it easier for  developers/integrators to build on top of the voting protocol. This API facilitates creating votings using Vocdoni, without the hassle of learning a complex blockchain platform, allowing to perform all the features that enable the voting protocol such as creating an account, entity, voting process, census & vote, abstracting as much as possible the complexity and offering simple and straightforward methods to perform those actions.   You can review the API endpoints documentation in this section, the main entities are:  - [**Chain**](chain): The Vocdoni blockchain is named Vochain. It is a Byzantine fault-tolerant network based on Tendermint that executes the Vocdoni Protocol logic represented as a state machine. Its main purpose is to register votes in a  decentralized and verifiable format. In those endpoints, you can consult the state of the chain, transactions costs,  list organizations and get more Vochain info. - [**Accounts**](accounts): Identified by an Ethereum like address. An account can create and manage elections, transfer tokens, give power to other accounts on his behalf (delegates) and manage its metadata. - [**Elections**](elections): Is a rule-set of options and requirements for creating a process in which people vote a series of options. To know more about the params of an election and its lifecycle go [here](../get-started/intro#23-elections). In this section you will find all information related to an election as its information, election keys, submitted votes & how to create a new election. - [**Censuses**](censuses): The census is a key component of any voting process. It specifies the set of users (identified by a public key or address) eligible for participating in an election. To understand more about the Censuses you can check [here](../get-started/intro#21-the-census). Here you will be able to get censuses information like the Merkle root, total weight & size, import/export the censuses and create new ones. - [**Votes**](votes): All the information related to the vote issued by a participant in a vote, you can check the validity of the vote, consult your information and send a vote. - [**SIK**](sik): The Secret Identity Key is a user-generated piece of information that proves the user's identity without revealing it. It is the hash of the user's address, the signature of a public message and an optional secret part. It is used to ensure anonymous voting. All registered accounts or anonymous voters must register a SIK, and they are all stored in a Merkle tree. The `/siks` endpoints help to generate a proof of membership, get the current valid SIK roots, or check if an account has a valid SIK.   ### Errors   Backend error messages list are defined here: https://github.com/vocdoni/vocdoni-node/blob/master/api/errors.go  About the **204 no content** error: this message will be returned only if the asset being queried cannot be found but no other errors have occurred. This response is commonly used to prevent Javascript errors that may arise when a client is waiting for a  transaction to be published. During this waiting period, the client can repeatedly query the endpoint until a  successful response with a status code of 200 is received, thereby avoiding any errors that may occur due to the transaction not being published yet.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.vocdoni.api;

import io.vocdoni.invoker.ApiCallback;
import io.vocdoni.invoker.ApiClient;
import io.vocdoni.invoker.ApiException;
import io.vocdoni.invoker.ApiResponse;
import io.vocdoni.invoker.Configuration;
import io.vocdoni.invoker.Pair;
import io.vocdoni.invoker.ProgressRequestBody;
import io.vocdoni.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.vocdoni.model.ApiCensusParticipants;
import io.vocdoni.model.CensusdbCensusDump;
import io.vocdoni.model.CensusesCensusIDProofKeyGet200Response;
import io.vocdoni.model.CensusesCensusIDPublishPost200Response;
import io.vocdoni.model.CensusesCensusIDPublishRootPost200Response;
import io.vocdoni.model.CensusesCensusIDRootGet200Response;
import io.vocdoni.model.CensusesCensusIDSizeGet200Response;
import io.vocdoni.model.CensusesCensusIDTypeGet200Response;
import io.vocdoni.model.CensusesCensusIDVerifyPost200Response;
import io.vocdoni.model.CensusesCensusIDWeightGet200Response;
import io.vocdoni.model.CensusesTypePost200Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CensusesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CensusesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public CensusesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for censusesCensusIDDelete
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDDeleteCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDDeleteValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDDelete(Async)");
        }

        return censusesCensusIDDeleteCall(censusID, _callback);

    }

    /**
     * Delete census
     * Delete unpublished census (not on the storage yet). See [publish census](census-publish)\\n - Requires Bearer token - Deletes a census from the server storage - Published census cannot be deleted
     * @param censusID Census id (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public void censusesCensusIDDelete(String censusID) throws ApiException {
        censusesCensusIDDeleteWithHttpInfo(censusID);
    }

    /**
     * Delete census
     * Delete unpublished census (not on the storage yet). See [publish census](census-publish)\\n - Requires Bearer token - Deletes a census from the server storage - Published census cannot be deleted
     * @param censusID Census id (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> censusesCensusIDDeleteWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDDeleteValidateBeforeCall(censusID, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete census (asynchronously)
     * Delete unpublished census (not on the storage yet). See [publish census](census-publish)\\n - Requires Bearer token - Deletes a census from the server storage - Published census cannot be deleted
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDDeleteAsync(String censusID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDDeleteValidateBeforeCall(censusID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDExportGet
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDExportGetCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/export"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDExportGetValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDExportGet(Async)");
        }

        return censusesCensusIDExportGetCall(censusID, _callback);

    }

    /**
     * Export census
     * Export census to JSON format. Requires Bearer token
     * @param censusID Census id (required)
     * @return CensusdbCensusDump
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CensusdbCensusDump censusesCensusIDExportGet(String censusID) throws ApiException {
        ApiResponse<CensusdbCensusDump> localVarResp = censusesCensusIDExportGetWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Export census
     * Export census to JSON format. Requires Bearer token
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusdbCensusDump&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusdbCensusDump> censusesCensusIDExportGetWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDExportGetValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusdbCensusDump>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Export census (asynchronously)
     * Export census to JSON format. Requires Bearer token
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDExportGetAsync(String censusID, final ApiCallback<CensusdbCensusDump> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDExportGetValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusdbCensusDump>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDImportPost
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDImportPostCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/import"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDImportPostValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDImportPost(Async)");
        }

        return censusesCensusIDImportPostCall(censusID, _callback);

    }

    /**
     * Import census
     * Import census from JSON previously exported using [&#x60;/censuses/{censusId}/export&#x60;](census-export). Requires Bearer token
     * @param censusID Census id (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public void censusesCensusIDImportPost(String censusID) throws ApiException {
        censusesCensusIDImportPostWithHttpInfo(censusID);
    }

    /**
     * Import census
     * Import census from JSON previously exported using [&#x60;/censuses/{censusId}/export&#x60;](census-export). Requires Bearer token
     * @param censusID Census id (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> censusesCensusIDImportPostWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDImportPostValidateBeforeCall(censusID, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Import census (asynchronously)
     * Import census from JSON previously exported using [&#x60;/censuses/{censusId}/export&#x60;](census-export). Requires Bearer token
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDImportPostAsync(String censusID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDImportPostValidateBeforeCall(censusID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDParticipantsPost
     * @param censusID Census id (required)
     * @param apiCensusParticipants PublicKey - weight array  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDParticipantsPostCall(String censusID, ApiCensusParticipants apiCensusParticipants, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = apiCensusParticipants;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/participants"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDParticipantsPostValidateBeforeCall(String censusID, ApiCensusParticipants apiCensusParticipants, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDParticipantsPost(Async)");
        }

        // verify the required parameter 'apiCensusParticipants' is set
        if (apiCensusParticipants == null) {
            throw new ApiException("Missing the required parameter 'apiCensusParticipants' when calling censusesCensusIDParticipantsPost(Async)");
        }

        return censusesCensusIDParticipantsPostCall(censusID, apiCensusParticipants, _callback);

    }

    /**
     * Add participants to census
     * Add list of public key/address with its weight to an unpublished census and returns the resulting  [Merkle Root](https://en.wikipedia.org/wiki/Merkle_tree).    Each addition will modify the census merkle root creating a new \&quot;snapshot\&quot; of the census at this moment. This root  identifies the census at this point and can be used to publish the census at this specific state.  For example, supposing a census with id &#x60;0x1234&#x60; (random hex string generated during census creation), add 10 keys will generate specific root for this state, ex &#x60;0xabcd&#x60;.   If we add 5 keys more, the resulting root changes, the keys are added and the new census have the first 10 keys plus the last 5, with a resulting root of &#x60;0xffff&#x60;.   So, at [publishing moment](census-publish), you could specify no root to publish census on the last  state (&#x60;0xffff&#x60;), which will publish the first 10 plus the last 5. Or either specify the snapshot point which you want to publish the census, for example &#x60;0x1234&#x60;, which will publish just the first 10th.  - Requires Bearer token  - Adds a list of wallet public key or wallet address to a census with a specific weight - If the weight parameter is missing, weight&#x3D;1 is considered
     * @param censusID Census id (required)
     * @param apiCensusParticipants PublicKey - weight array  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public void censusesCensusIDParticipantsPost(String censusID, ApiCensusParticipants apiCensusParticipants) throws ApiException {
        censusesCensusIDParticipantsPostWithHttpInfo(censusID, apiCensusParticipants);
    }

    /**
     * Add participants to census
     * Add list of public key/address with its weight to an unpublished census and returns the resulting  [Merkle Root](https://en.wikipedia.org/wiki/Merkle_tree).    Each addition will modify the census merkle root creating a new \&quot;snapshot\&quot; of the census at this moment. This root  identifies the census at this point and can be used to publish the census at this specific state.  For example, supposing a census with id &#x60;0x1234&#x60; (random hex string generated during census creation), add 10 keys will generate specific root for this state, ex &#x60;0xabcd&#x60;.   If we add 5 keys more, the resulting root changes, the keys are added and the new census have the first 10 keys plus the last 5, with a resulting root of &#x60;0xffff&#x60;.   So, at [publishing moment](census-publish), you could specify no root to publish census on the last  state (&#x60;0xffff&#x60;), which will publish the first 10 plus the last 5. Or either specify the snapshot point which you want to publish the census, for example &#x60;0x1234&#x60;, which will publish just the first 10th.  - Requires Bearer token  - Adds a list of wallet public key or wallet address to a census with a specific weight - If the weight parameter is missing, weight&#x3D;1 is considered
     * @param censusID Census id (required)
     * @param apiCensusParticipants PublicKey - weight array  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> censusesCensusIDParticipantsPostWithHttpInfo(String censusID, ApiCensusParticipants apiCensusParticipants) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDParticipantsPostValidateBeforeCall(censusID, apiCensusParticipants, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Add participants to census (asynchronously)
     * Add list of public key/address with its weight to an unpublished census and returns the resulting  [Merkle Root](https://en.wikipedia.org/wiki/Merkle_tree).    Each addition will modify the census merkle root creating a new \&quot;snapshot\&quot; of the census at this moment. This root  identifies the census at this point and can be used to publish the census at this specific state.  For example, supposing a census with id &#x60;0x1234&#x60; (random hex string generated during census creation), add 10 keys will generate specific root for this state, ex &#x60;0xabcd&#x60;.   If we add 5 keys more, the resulting root changes, the keys are added and the new census have the first 10 keys plus the last 5, with a resulting root of &#x60;0xffff&#x60;.   So, at [publishing moment](census-publish), you could specify no root to publish census on the last  state (&#x60;0xffff&#x60;), which will publish the first 10 plus the last 5. Or either specify the snapshot point which you want to publish the census, for example &#x60;0x1234&#x60;, which will publish just the first 10th.  - Requires Bearer token  - Adds a list of wallet public key or wallet address to a census with a specific weight - If the weight parameter is missing, weight&#x3D;1 is considered
     * @param censusID Census id (required)
     * @param apiCensusParticipants PublicKey - weight array  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> (empty body) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDParticipantsPostAsync(String censusID, ApiCensusParticipants apiCensusParticipants, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDParticipantsPostValidateBeforeCall(censusID, apiCensusParticipants, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDProofKeyGet
     * @param censusID Census id (required)
     * @param key Key to proof (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> where proof is Merkle tree siblings and value is Merkle tree leaf value </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDProofKeyGetCall(String censusID, String key, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/proof/{key}"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()))
            .replace("{" + "key" + "}", localVarApiClient.escapeString(key.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDProofKeyGetValidateBeforeCall(String censusID, String key, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDProofKeyGet(Async)");
        }

        // verify the required parameter 'key' is set
        if (key == null) {
            throw new ApiException("Missing the required parameter 'key' when calling censusesCensusIDProofKeyGet(Async)");
        }

        return censusesCensusIDProofKeyGetCall(censusID, key, _callback);

    }

    /**
     * Prove key to census
     * Prove the key and weight belong to the census root hash.  If the key exists on the census returns Merkle root information. &#x60;Proof&#x60; property is referred to the siblings of Merkle tree, the &#x60;value&#x60; points to the leaf of the Merkle Tree for this key (on this case, the weight), and weight is just the key weight for this census.   [Further reading](/protocol/Census/off-chain-tree)  - Requires Bearer token  - Returns a merkle proof, proving the key and weight belongs to the census root hash
     * @param censusID Census id (required)
     * @param key Key to proof (required)
     * @return CensusesCensusIDProofKeyGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> where proof is Merkle tree siblings and value is Merkle tree leaf value </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDProofKeyGet200Response censusesCensusIDProofKeyGet(String censusID, String key) throws ApiException {
        ApiResponse<CensusesCensusIDProofKeyGet200Response> localVarResp = censusesCensusIDProofKeyGetWithHttpInfo(censusID, key);
        return localVarResp.getData();
    }

    /**
     * Prove key to census
     * Prove the key and weight belong to the census root hash.  If the key exists on the census returns Merkle root information. &#x60;Proof&#x60; property is referred to the siblings of Merkle tree, the &#x60;value&#x60; points to the leaf of the Merkle Tree for this key (on this case, the weight), and weight is just the key weight for this census.   [Further reading](/protocol/Census/off-chain-tree)  - Requires Bearer token  - Returns a merkle proof, proving the key and weight belongs to the census root hash
     * @param censusID Census id (required)
     * @param key Key to proof (required)
     * @return ApiResponse&lt;CensusesCensusIDProofKeyGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> where proof is Merkle tree siblings and value is Merkle tree leaf value </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDProofKeyGet200Response> censusesCensusIDProofKeyGetWithHttpInfo(String censusID, String key) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDProofKeyGetValidateBeforeCall(censusID, key, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDProofKeyGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Prove key to census (asynchronously)
     * Prove the key and weight belong to the census root hash.  If the key exists on the census returns Merkle root information. &#x60;Proof&#x60; property is referred to the siblings of Merkle tree, the &#x60;value&#x60; points to the leaf of the Merkle Tree for this key (on this case, the weight), and weight is just the key weight for this census.   [Further reading](/protocol/Census/off-chain-tree)  - Requires Bearer token  - Returns a merkle proof, proving the key and weight belongs to the census root hash
     * @param censusID Census id (required)
     * @param key Key to proof (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> where proof is Merkle tree siblings and value is Merkle tree leaf value </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDProofKeyGetAsync(String censusID, String key, final ApiCallback<CensusesCensusIDProofKeyGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDProofKeyGetValidateBeforeCall(censusID, key, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDProofKeyGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDPublishPost
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDPublishPostCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/publish"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDPublishPostValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDPublishPost(Async)");
        }

        return censusesCensusIDPublishPostCall(censusID, _callback);

    }

    /**
     * Publish census
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @return CensusesCensusIDPublishPost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDPublishPost200Response censusesCensusIDPublishPost(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDPublishPost200Response> localVarResp = censusesCensusIDPublishPostWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Publish census
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDPublishPost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDPublishPost200Response> censusesCensusIDPublishPostWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDPublishPostValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDPublishPost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Publish census (asynchronously)
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDPublishPostAsync(String censusID, final ApiCallback<CensusesCensusIDPublishPost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDPublishPostValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDPublishPost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDPublishRootPost
     * @param censusID Census id (required)
     * @param root Specific root where to publish the census. Not required (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDPublishRootPostCall(String censusID, String root, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/publish/{root}"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()))
            .replace("{" + "root" + "}", localVarApiClient.escapeString(root.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDPublishRootPostValidateBeforeCall(String censusID, String root, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDPublishRootPost(Async)");
        }

        // verify the required parameter 'root' is set
        if (root == null) {
            throw new ApiException("Missing the required parameter 'root' when calling censusesCensusIDPublishRootPost(Async)");
        }

        return censusesCensusIDPublishRootPostCall(censusID, root, _callback);

    }

    /**
     * Publish census at root
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @param root Specific root where to publish the census. Not required (required)
     * @return CensusesCensusIDPublishRootPost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDPublishRootPost200Response censusesCensusIDPublishRootPost(String censusID, String root) throws ApiException {
        ApiResponse<CensusesCensusIDPublishRootPost200Response> localVarResp = censusesCensusIDPublishRootPostWithHttpInfo(censusID, root);
        return localVarResp.getData();
    }

    /**
     * Publish census at root
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @param root Specific root where to publish the census. Not required (required)
     * @return ApiResponse&lt;CensusesCensusIDPublishRootPost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDPublishRootPost200Response> censusesCensusIDPublishRootPostWithHttpInfo(String censusID, String root) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDPublishRootPostValidateBeforeCall(censusID, root, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDPublishRootPost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Publish census at root (asynchronously)
     * Register a census to the storage (IPFS in our case). After this, the census can&#39;t be edited.           You could provide the census Merkle root to specify census publication at specific snapshot. See [censuses/{censusId}/participants](census-add-participants-to-census)  - Requires Bearer token - The census is copied to a new census identified by its Merkle Root - The new census **cannot be modified** - The census is published to the storage provided (IPFS in our case) - The new census ID is returned and can be used for querying - If a censusID with the same root has been already published, the request will fail - If &#x60;root&#x60; is specified as path parameter, it publish the census at specific  root (append the census to existing one).
     * @param censusID Census id (required)
     * @param root Specific root where to publish the census. Not required (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return published censusID and the ipfs uri where its uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDPublishRootPostAsync(String censusID, String root, final ApiCallback<CensusesCensusIDPublishRootPost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDPublishRootPostValidateBeforeCall(censusID, root, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDPublishRootPost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDRootGet
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Merkle root of the census </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDRootGetCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/root"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDRootGetValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDRootGet(Async)");
        }

        return censusesCensusIDRootGetCall(censusID, _callback);

    }

    /**
     * Census Merkle Root
     * Get census [Merkle Tree root](https://docs.vocdoni.io/architecture/census/off-chain-tree.html) hash, used to identify the census at specific snapshot.\\n\\n- Bearer token not required
     * @param censusID Census id (required)
     * @return CensusesCensusIDRootGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Merkle root of the census </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDRootGet200Response censusesCensusIDRootGet(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDRootGet200Response> localVarResp = censusesCensusIDRootGetWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Census Merkle Root
     * Get census [Merkle Tree root](https://docs.vocdoni.io/architecture/census/off-chain-tree.html) hash, used to identify the census at specific snapshot.\\n\\n- Bearer token not required
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDRootGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Merkle root of the census </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDRootGet200Response> censusesCensusIDRootGetWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDRootGetValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDRootGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Census Merkle Root (asynchronously)
     * Get census [Merkle Tree root](https://docs.vocdoni.io/architecture/census/off-chain-tree.html) hash, used to identify the census at specific snapshot.\\n\\n- Bearer token not required
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Merkle root of the census </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDRootGetAsync(String censusID, final ApiCallback<CensusesCensusIDRootGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDRootGetValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDRootGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDSizeGet
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Size as integer </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDSizeGetCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/size"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDSizeGetValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDSizeGet(Async)");
        }

        return censusesCensusIDSizeGetCall(censusID, _callback);

    }

    /**
     * Census size
     * Total number of keys added to the census. Size as integer
     * @param censusID Census id (required)
     * @return CensusesCensusIDSizeGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Size as integer </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDSizeGet200Response censusesCensusIDSizeGet(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDSizeGet200Response> localVarResp = censusesCensusIDSizeGetWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Census size
     * Total number of keys added to the census. Size as integer
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDSizeGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Size as integer </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDSizeGet200Response> censusesCensusIDSizeGetWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDSizeGetValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDSizeGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Census size (asynchronously)
     * Total number of keys added to the census. Size as integer
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Size as integer </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDSizeGetAsync(String censusID, final ApiCallback<CensusesCensusIDSizeGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDSizeGetValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDSizeGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDTypeGet
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Census type \&quot;weighted\&quot;, \&quot;zkweighted\&quot;, \&quot;csp </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDTypeGetCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/type"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDTypeGetValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDTypeGet(Async)");
        }

        return censusesCensusIDTypeGetCall(censusID, _callback);

    }

    /**
     * Get type of census
     * Get the type of a census
     * @param censusID Census id (required)
     * @return CensusesCensusIDTypeGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Census type \&quot;weighted\&quot;, \&quot;zkweighted\&quot;, \&quot;csp </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDTypeGet200Response censusesCensusIDTypeGet(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDTypeGet200Response> localVarResp = censusesCensusIDTypeGetWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Get type of census
     * Get the type of a census
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDTypeGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Census type \&quot;weighted\&quot;, \&quot;zkweighted\&quot;, \&quot;csp </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDTypeGet200Response> censusesCensusIDTypeGetWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDTypeGetValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDTypeGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get type of census (asynchronously)
     * Get the type of a census
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Census type \&quot;weighted\&quot;, \&quot;zkweighted\&quot;, \&quot;csp </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDTypeGetAsync(String censusID, final ApiCallback<CensusesCensusIDTypeGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDTypeGetValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDTypeGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDVerifyPost
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDVerifyPostCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/verify"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDVerifyPostValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDVerifyPost(Async)");
        }

        return censusesCensusIDVerifyPostCall(censusID, _callback);

    }

    /**
     * Verify merkle proof
     * Verify that a previously obtained Merkle proof for a key, acquired via [/censuses/{censusId}/proof/{publicKey}](prove-key-to-census) is still correct.
     * @param censusID Census id (required)
     * @return CensusesCensusIDVerifyPost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDVerifyPost200Response censusesCensusIDVerifyPost(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDVerifyPost200Response> localVarResp = censusesCensusIDVerifyPostWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Verify merkle proof
     * Verify that a previously obtained Merkle proof for a key, acquired via [/censuses/{censusId}/proof/{publicKey}](prove-key-to-census) is still correct.
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDVerifyPost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDVerifyPost200Response> censusesCensusIDVerifyPostWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDVerifyPostValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDVerifyPost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Verify merkle proof (asynchronously)
     * Verify that a previously obtained Merkle proof for a key, acquired via [/censuses/{censusId}/proof/{publicKey}](prove-key-to-census) is still correct.
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDVerifyPostAsync(String censusID, final ApiCallback<CensusesCensusIDVerifyPost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDVerifyPostValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDVerifyPost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesCensusIDWeightGet
     * @param censusID Census id (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sum of weight son a stringfied big int format </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDWeightGetCall(String censusID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{censusID}/weight"
            .replace("{" + "censusID" + "}", localVarApiClient.escapeString(censusID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesCensusIDWeightGetValidateBeforeCall(String censusID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'censusID' is set
        if (censusID == null) {
            throw new ApiException("Missing the required parameter 'censusID' when calling censusesCensusIDWeightGet(Async)");
        }

        return censusesCensusIDWeightGetCall(censusID, _callback);

    }

    /**
     * Census total weight
     * It sums all weights added to the census. Weight is a stringified bigInt
     * @param censusID Census id (required)
     * @return CensusesCensusIDWeightGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sum of weight son a stringfied big int format </td><td>  -  </td></tr>
     </table>
     */
    public CensusesCensusIDWeightGet200Response censusesCensusIDWeightGet(String censusID) throws ApiException {
        ApiResponse<CensusesCensusIDWeightGet200Response> localVarResp = censusesCensusIDWeightGetWithHttpInfo(censusID);
        return localVarResp.getData();
    }

    /**
     * Census total weight
     * It sums all weights added to the census. Weight is a stringified bigInt
     * @param censusID Census id (required)
     * @return ApiResponse&lt;CensusesCensusIDWeightGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sum of weight son a stringfied big int format </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesCensusIDWeightGet200Response> censusesCensusIDWeightGetWithHttpInfo(String censusID) throws ApiException {
        okhttp3.Call localVarCall = censusesCensusIDWeightGetValidateBeforeCall(censusID, null);
        Type localVarReturnType = new TypeToken<CensusesCensusIDWeightGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Census total weight (asynchronously)
     * It sums all weights added to the census. Weight is a stringified bigInt
     * @param censusID Census id (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sum of weight son a stringfied big int format </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesCensusIDWeightGetAsync(String censusID, final ApiCallback<CensusesCensusIDWeightGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesCensusIDWeightGetValidateBeforeCall(censusID, _callback);
        Type localVarReturnType = new TypeToken<CensusesCensusIDWeightGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for censusesTypePost
     * @param type Census type (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesTypePostCall(String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/censuses/{type}"
            .replace("{" + "type" + "}", localVarApiClient.escapeString(type.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BasicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call censusesTypePostValidateBeforeCall(String type, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling censusesTypePost(Async)");
        }

        return censusesTypePostCall(type, _callback);

    }

    /**
     * Create a new census
     * Create a new census on the backend side. The census is still unpublished until [publish](publish-census) is called.    To create the census it require a &#x60;Bearer token&#x60; created on the user side using a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier). This token **should we stored for the user to perform operations to this census** such add participants or publish.  It return a new random censusID (a random 32 bytes hex string), which are used (along with the Bearer token) to [add participant keys](add-participants-to-census) to the census. Once the census is published no more keys can be added.  To use a census on an election, it **must be published**.  - Available types are: &#x60;weighted&#x60; and &#x60;zkindexed&#x60; - Require header Bearer token created user side
     * @param type Census type (required)
     * @return CensusesTypePost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CensusesTypePost200Response censusesTypePost(String type) throws ApiException {
        ApiResponse<CensusesTypePost200Response> localVarResp = censusesTypePostWithHttpInfo(type);
        return localVarResp.getData();
    }

    /**
     * Create a new census
     * Create a new census on the backend side. The census is still unpublished until [publish](publish-census) is called.    To create the census it require a &#x60;Bearer token&#x60; created on the user side using a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier). This token **should we stored for the user to perform operations to this census** such add participants or publish.  It return a new random censusID (a random 32 bytes hex string), which are used (along with the Bearer token) to [add participant keys](add-participants-to-census) to the census. Once the census is published no more keys can be added.  To use a census on an election, it **must be published**.  - Available types are: &#x60;weighted&#x60; and &#x60;zkindexed&#x60; - Require header Bearer token created user side
     * @param type Census type (required)
     * @return ApiResponse&lt;CensusesTypePost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CensusesTypePost200Response> censusesTypePostWithHttpInfo(String type) throws ApiException {
        okhttp3.Call localVarCall = censusesTypePostValidateBeforeCall(type, null);
        Type localVarReturnType = new TypeToken<CensusesTypePost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a new census (asynchronously)
     * Create a new census on the backend side. The census is still unpublished until [publish](publish-census) is called.    To create the census it require a &#x60;Bearer token&#x60; created on the user side using a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier). This token **should we stored for the user to perform operations to this census** such add participants or publish.  It return a new random censusID (a random 32 bytes hex string), which are used (along with the Bearer token) to [add participant keys](add-participants-to-census) to the census. Once the census is published no more keys can be added.  To use a census on an election, it **must be published**.  - Available types are: &#x60;weighted&#x60; and &#x60;zkindexed&#x60; - Require header Bearer token created user side
     * @param type Census type (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call censusesTypePostAsync(String type, final ApiCallback<CensusesTypePost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = censusesTypePostValidateBeforeCall(type, _callback);
        Type localVarReturnType = new TypeToken<CensusesTypePost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
