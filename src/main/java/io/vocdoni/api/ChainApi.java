/*
 * Vocdoni API
 * The Vocdoni API is a REST API that substitutes the previous RPCs in order to make it easier for  developers/integrators to build on top of the voting protocol. This API facilitates creating votings using Vocdoni, without the hassle of learning a complex blockchain platform, allowing to perform all the features that enable the voting protocol such as creating an account, entity, voting process, census & vote, abstracting as much as possible the complexity and offering simple and straightforward methods to perform those actions.   You can review the API endpoints documentation in this section, the main entities are:  - [**Chain**](chain): The Vocdoni blockchain is named Vochain. It is a Byzantine fault-tolerant network based on Tendermint that executes the Vocdoni Protocol logic represented as a state machine. Its main purpose is to register votes in a  decentralized and verifiable format. In those endpoints, you can consult the state of the chain, transactions costs,  list organizations and get more Vochain info. - [**Accounts**](accounts): Identified by an Ethereum like address. An account can create and manage elections, transfer tokens, give power to other accounts on his behalf (delegates) and manage its metadata. - [**Elections**](elections): Is a rule-set of options and requirements for creating a process in which people vote a series of options. To know more about the params of an election and its lifecycle go [here](../get-started/intro#23-elections). In this section you will find all information related to an election as its information, election keys, submitted votes & how to create a new election. - [**Censuses**](censuses): The census is a key component of any voting process. It specifies the set of users (identified by a public key or address) eligible for participating in an election. To understand more about the Censuses you can check [here](../get-started/intro#21-the-census). Here you will be able to get censuses information like the Merkle root, total weight & size, import/export the censuses and create new ones. - [**Votes**](votes): All the information related to the vote issued by a participant in a vote, you can check the validity of the vote, consult your information and send a vote. - [**SIK**](sik): The Secret Identity Key is a user-generated piece of information that proves the user's identity without revealing it. It is the hash of the user's address, the signature of a public message and an optional secret part. It is used to ensure anonymous voting. All registered accounts or anonymous voters must register a SIK, and they are all stored in a Merkle tree. The `/siks` endpoints help to generate a proof of membership, get the current valid SIK roots, or check if an account has a valid SIK.   ### Errors   Backend error messages list are defined here: https://github.com/vocdoni/vocdoni-node/blob/master/api/errors.go  About the **204 no content** error: this message will be returned only if the asset being queried cannot be found but no other errors have occurred. This response is commonly used to prevent Javascript errors that may arise when a client is waiting for a  transaction to be published. During this waiting period, the client can repeatedly query the endpoint until a  successful response with a status code of 200 is received, thereby avoiding any errors that may occur due to the transaction not being published yet.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.vocdoni.api;

import io.vocdoni.invoker.ApiCallback;
import io.vocdoni.invoker.ApiClient;
import io.vocdoni.invoker.ApiException;
import io.vocdoni.invoker.ApiResponse;
import io.vocdoni.invoker.Configuration;
import io.vocdoni.invoker.Pair;
import io.vocdoni.invoker.ProgressRequestBody;
import io.vocdoni.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.vocdoni.model.AccountsOrganizationIDElectionsCountGet200Response;
import io.vocdoni.model.ApiBlock;
import io.vocdoni.model.ApiChainInfo;
import io.vocdoni.model.ApiChainTxListPaginatedResponse;
import io.vocdoni.model.ApiGenericTransactionWithInfo;
import io.vocdoni.model.ApiOrganizationListHandlerResponse;
import io.vocdoni.model.ApiTransaction;
import io.vocdoni.model.ApiTransactionMetadata;
import io.vocdoni.model.ApiValidatorList;
import java.math.BigDecimal;
import io.vocdoni.model.ChainBlockToDateHeightGet200Response;
import io.vocdoni.model.ChainDateToBlockTimestampGet200Response;
import io.vocdoni.model.ChainOrganizationsCountGet200Response;
import io.vocdoni.model.ChainOrganizationsFilterPagePagePost200Response;
import io.vocdoni.model.ChainOrganizationsFilterPagePagePostRequest;
import io.vocdoni.model.ChainTransactionsPostRequest;
import io.vocdoni.model.CircuitZkCircuitConfig;
import io.vocdoni.model.ElectionpriceCalculator;
import io.vocdoni.model.GenesisTransactionCosts;
import io.vocdoni.model.IndexertypesTransaction;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ChainApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ChainApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ChainApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for chainBlockToDateHeightGet
     * @param height Block height (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlockToDateHeightGetCall(BigDecimal height, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/blockToDate/{height}"
            .replace("{" + "height" + "}", localVarApiClient.escapeString(height.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainBlockToDateHeightGetValidateBeforeCall(BigDecimal height, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'height' is set
        if (height == null) {
            throw new ApiException("Missing the required parameter 'height' when calling chainBlockToDateHeightGet(Async)");
        }

        return chainBlockToDateHeightGetCall(height, _callback);

    }

    /**
     * Estimate block to date
     * Returns the estimated timestamp for the block height provided
     * @param height Block height (required)
     * @return ChainBlockToDateHeightGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ChainBlockToDateHeightGet200Response chainBlockToDateHeightGet(BigDecimal height) throws ApiException {
        ApiResponse<ChainBlockToDateHeightGet200Response> localVarResp = chainBlockToDateHeightGetWithHttpInfo(height);
        return localVarResp.getData();
    }

    /**
     * Estimate block to date
     * Returns the estimated timestamp for the block height provided
     * @param height Block height (required)
     * @return ApiResponse&lt;ChainBlockToDateHeightGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChainBlockToDateHeightGet200Response> chainBlockToDateHeightGetWithHttpInfo(BigDecimal height) throws ApiException {
        okhttp3.Call localVarCall = chainBlockToDateHeightGetValidateBeforeCall(height, null);
        Type localVarReturnType = new TypeToken<ChainBlockToDateHeightGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Estimate block to date (asynchronously)
     * Returns the estimated timestamp for the block height provided
     * @param height Block height (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlockToDateHeightGetAsync(BigDecimal height, final ApiCallback<ChainBlockToDateHeightGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainBlockToDateHeightGetValidateBeforeCall(height, _callback);
        Type localVarReturnType = new TypeToken<ChainBlockToDateHeightGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainBlocksHashHashGet
     * @param hash Block hash (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHashHashGetCall(String hash, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/blocks/hash/{hash}"
            .replace("{" + "hash" + "}", localVarApiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainBlocksHashHashGetValidateBeforeCall(String hash, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling chainBlocksHashHashGet(Async)");
        }

        return chainBlocksHashHashGetCall(hash, _callback);

    }

    /**
     * Get block (by hash)
     * Returns the block from the given hash
     * @param hash Block hash (required)
     * @return ApiBlock
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiBlock chainBlocksHashHashGet(String hash) throws ApiException {
        ApiResponse<ApiBlock> localVarResp = chainBlocksHashHashGetWithHttpInfo(hash);
        return localVarResp.getData();
    }

    /**
     * Get block (by hash)
     * Returns the block from the given hash
     * @param hash Block hash (required)
     * @return ApiResponse&lt;ApiBlock&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiBlock> chainBlocksHashHashGetWithHttpInfo(String hash) throws ApiException {
        okhttp3.Call localVarCall = chainBlocksHashHashGetValidateBeforeCall(hash, null);
        Type localVarReturnType = new TypeToken<ApiBlock>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get block (by hash) (asynchronously)
     * Returns the block from the given hash
     * @param hash Block hash (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHashHashGetAsync(String hash, final ApiCallback<ApiBlock> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainBlocksHashHashGetValidateBeforeCall(hash, _callback);
        Type localVarReturnType = new TypeToken<ApiBlock>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainBlocksHeightGet
     * @param height Block height (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHeightGetCall(Integer height, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/blocks/{height}"
            .replace("{" + "height" + "}", localVarApiClient.escapeString(height.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainBlocksHeightGetValidateBeforeCall(Integer height, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'height' is set
        if (height == null) {
            throw new ApiException("Missing the required parameter 'height' when calling chainBlocksHeightGet(Async)");
        }

        return chainBlocksHeightGetCall(height, _callback);

    }

    /**
     * Get block (by height)
     * Returns the full block information at the given height
     * @param height Block height (required)
     * @return ApiBlock
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiBlock chainBlocksHeightGet(Integer height) throws ApiException {
        ApiResponse<ApiBlock> localVarResp = chainBlocksHeightGetWithHttpInfo(height);
        return localVarResp.getData();
    }

    /**
     * Get block (by height)
     * Returns the full block information at the given height
     * @param height Block height (required)
     * @return ApiResponse&lt;ApiBlock&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiBlock> chainBlocksHeightGetWithHttpInfo(Integer height) throws ApiException {
        okhttp3.Call localVarCall = chainBlocksHeightGetValidateBeforeCall(height, null);
        Type localVarReturnType = new TypeToken<ApiBlock>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get block (by height) (asynchronously)
     * Returns the full block information at the given height
     * @param height Block height (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHeightGetAsync(Integer height, final ApiCallback<ApiBlock> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainBlocksHeightGetValidateBeforeCall(height, _callback);
        Type localVarReturnType = new TypeToken<ApiBlock>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainBlocksHeightTransactionsPagePageGet
     * @param height Block height (required)
     * @param page Page to paginate (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHeightTransactionsPagePageGetCall(BigDecimal height, BigDecimal page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/blocks/{height}/transactions/page/{page}"
            .replace("{" + "height" + "}", localVarApiClient.escapeString(height.toString()))
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainBlocksHeightTransactionsPagePageGetValidateBeforeCall(BigDecimal height, BigDecimal page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'height' is set
        if (height == null) {
            throw new ApiException("Missing the required parameter 'height' when calling chainBlocksHeightTransactionsPagePageGet(Async)");
        }

        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling chainBlocksHeightTransactionsPagePageGet(Async)");
        }

        return chainBlocksHeightTransactionsPagePageGetCall(height, page, _callback);

    }

    /**
     * Transactions in a block
     * Given a block returns the list of transactions for that block
     * @param height Block height (required)
     * @param page Page to paginate (required)
     * @return List&lt;ApiTransactionMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ApiTransactionMetadata> chainBlocksHeightTransactionsPagePageGet(BigDecimal height, BigDecimal page) throws ApiException {
        ApiResponse<List<ApiTransactionMetadata>> localVarResp = chainBlocksHeightTransactionsPagePageGetWithHttpInfo(height, page);
        return localVarResp.getData();
    }

    /**
     * Transactions in a block
     * Given a block returns the list of transactions for that block
     * @param height Block height (required)
     * @param page Page to paginate (required)
     * @return ApiResponse&lt;List&lt;ApiTransactionMetadata&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ApiTransactionMetadata>> chainBlocksHeightTransactionsPagePageGetWithHttpInfo(BigDecimal height, BigDecimal page) throws ApiException {
        okhttp3.Call localVarCall = chainBlocksHeightTransactionsPagePageGetValidateBeforeCall(height, page, null);
        Type localVarReturnType = new TypeToken<List<ApiTransactionMetadata>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transactions in a block (asynchronously)
     * Given a block returns the list of transactions for that block
     * @param height Block height (required)
     * @param page Page to paginate (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainBlocksHeightTransactionsPagePageGetAsync(BigDecimal height, BigDecimal page, final ApiCallback<List<ApiTransactionMetadata>> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainBlocksHeightTransactionsPagePageGetValidateBeforeCall(height, page, _callback);
        Type localVarReturnType = new TypeToken<List<ApiTransactionMetadata>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainDateToBlockTimestampGet
     * @param timestamp Timestamp on unix format (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Estimated block height </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainDateToBlockTimestampGetCall(String timestamp, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/dateToBlock/{timestamp}"
            .replace("{" + "timestamp" + "}", localVarApiClient.escapeString(timestamp.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainDateToBlockTimestampGetValidateBeforeCall(String timestamp, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'timestamp' is set
        if (timestamp == null) {
            throw new ApiException("Missing the required parameter 'timestamp' when calling chainDateToBlockTimestampGet(Async)");
        }

        return chainDateToBlockTimestampGetCall(timestamp, _callback);

    }

    /**
     * Estimate date to block
     * Returns the estimated block height for the timestamp provided
     * @param timestamp Timestamp on unix format (required)
     * @return ChainDateToBlockTimestampGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Estimated block height </td><td>  -  </td></tr>
     </table>
     */
    public ChainDateToBlockTimestampGet200Response chainDateToBlockTimestampGet(String timestamp) throws ApiException {
        ApiResponse<ChainDateToBlockTimestampGet200Response> localVarResp = chainDateToBlockTimestampGetWithHttpInfo(timestamp);
        return localVarResp.getData();
    }

    /**
     * Estimate date to block
     * Returns the estimated block height for the timestamp provided
     * @param timestamp Timestamp on unix format (required)
     * @return ApiResponse&lt;ChainDateToBlockTimestampGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Estimated block height </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChainDateToBlockTimestampGet200Response> chainDateToBlockTimestampGetWithHttpInfo(String timestamp) throws ApiException {
        okhttp3.Call localVarCall = chainDateToBlockTimestampGetValidateBeforeCall(timestamp, null);
        Type localVarReturnType = new TypeToken<ChainDateToBlockTimestampGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Estimate date to block (asynchronously)
     * Returns the estimated block height for the timestamp provided
     * @param timestamp Timestamp on unix format (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Estimated block height </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainDateToBlockTimestampGetAsync(String timestamp, final ApiCallback<ChainDateToBlockTimestampGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainDateToBlockTimestampGetValidateBeforeCall(timestamp, _callback);
        Type localVarReturnType = new TypeToken<ChainDateToBlockTimestampGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainInfoCircuitGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoCircuitGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/info/circuit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainInfoCircuitGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainInfoCircuitGetCall(_callback);

    }

    /**
     * Circuit info
     * Returns the circuit configuration according to the current circuit
     * @return CircuitZkCircuitConfig
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CircuitZkCircuitConfig chainInfoCircuitGet() throws ApiException {
        ApiResponse<CircuitZkCircuitConfig> localVarResp = chainInfoCircuitGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Circuit info
     * Returns the circuit configuration according to the current circuit
     * @return ApiResponse&lt;CircuitZkCircuitConfig&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CircuitZkCircuitConfig> chainInfoCircuitGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainInfoCircuitGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<CircuitZkCircuitConfig>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Circuit info (asynchronously)
     * Returns the circuit configuration according to the current circuit
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoCircuitGetAsync(final ApiCallback<CircuitZkCircuitConfig> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainInfoCircuitGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<CircuitZkCircuitConfig>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainInfoElectionPriceFactorsGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoElectionPriceFactorsGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/info/electionPriceFactors";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainInfoElectionPriceFactorsGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainInfoElectionPriceFactorsGetCall(_callback);

    }

    /**
     * Price factors information
     * Package electionprice provides a mechanism for calculating the price of an election based on its characteristics.  The formula used to calculate the price for creating an election on the Vocdoni blockchain is designed to take into account various factors that impact the cost and complexity of conducting an election. The price is determined by combining several components, each reflecting a specific aspect of the election process.  1. **Base Price**: This is a fixed cost that serves as a starting point for the price calculation. It represents the minimal price for creating an election, regardless of its size or duration. 2. **Size Price**: As the number of voters (maxCensusSize) in an election increases, the resources required to manage the election also grow. To account for this, the size price component is directly proportional to the maximum number of votes allowed in the election. Additionally, it takes into consideration the blockchain&#39;s maximum capacity (capacity) and the maximum capacity the blockchain administrators can set (maxCapacity). This ensures that the price is adjusted based on the current capacity of the blockchain. 3. **Duration Price**: The length of the election (electionDuration) also affects the price, as longer elections occupy more resources over time. The duration price component is directly proportional to the election duration and inversely proportional to the maximum number of votes. This means that if the election lasts longer, the price increases, and if there are more votes in a shorter time, the price also increases to reflect the higher demand for resources. 4. **Encrypted Votes**: If an election requires encryption for maintaining secrecy until the end (encryptedVotes), it demands additional resources and computational effort. Therefore, the encrypted price component is added to the total price when this feature is enabled. 5. **Anonymous Votes**: Similarly, if an election must be anonymous (anonymousVotes), it requires additional measures to ensure voter privacy. As a result, the anonymous price component is added to the total price when this option is chosen. 6. **Overwrite Price**: Allowing voters to overwrite their votes (maxVoteOverwrite) can increase the complexity of managing the election, as it requires additional resources to handle vote updates. The overwrite price component accounts for this by being proportional to the maximum number of vote overwrites and the maximum number of votes allowed in the election. It also takes into account the blockchain&#39;s capacity to ensure the price reflects the current resource constraints.  The constant factors in the price formula play a crucial role in determining the price of an election based on its characteristics. Each factor is associated with a specific component of the price formula and helps to weigh the importance of that component in the final price calculation. The rationale beind these constant factors is to provide a flexible mechanism to adjust the pricing model based on the system&#39;s needs and requirements.  - **k1 (Size price factor)**: This constant factor affects the size price component of the formula. By adjusting k1, you can control the impact of the maximum number of votes (maxCensusSize) on the overall price. A higher k1 value would make the price increase more rapidly as the election size grows, while a lower k1 value would make the price less sensitive to the election size. The rationale behind k1 is to ensure that the pricing model can be adapted to accommodate different election sizes while considering the resource requirements. - **k2 (Duration price factor)**: This constant factor influences the duration price component of the formula. By adjusting k2, you can control how the duration of the election (electionDuration) affects the price. A higher k2 value would make the price increase more quickly as the election duration extends, while a lower k2 value would make the price less sensitive to the election duration. The rationale behind k2 is to reflect the resource consumption over time and ensure that longer elections are priced accordingly. - **k3 (Encrypted price factor)**: This constant factor affects the encrypted price component of the formula. By adjusting k3, you can control the additional cost associated with encrypted elections (encryptedVotes). A higher k3 value would make the price increase more significantly for elections that require encryption, while a lower k3 value would make the price less sensitive to the encryption requirement. The rationale behind k3 is to account for the extra computational effort and resources needed to ensure secrecy in encrypted elections. - **k4 (Anonymous price factor)**: This constant factor influences the anonymous price component of the formula. By adjusting k4, you can control the additional cost associated with anonymous elections (anonymousVotes). A higher k4 value would make the price increase more significantly for elections that require anonymity, while a lower k4 value would make the price less sensitive to the anonymity requirement. The rationale behind k4 is to account for the extra measures and resources needed to ensure voter privacy in anonymous elections. - **k5 (Overwrite price factor)**: This constant factor affects the overwrite price component of the formula. By adjusting k5, you can control the additional cost associated with allowing vote overwrites (maxVoteOverwrite). A higher k5 value would make the price increase more significantly for elections that permit vote overwrites, while a lower k5 value would make the price less sensitive to the overwrite allowance. The rationale behind k5 is to account for the increased complexity and resources needed to manage vote overwrites in the election process. - **k6 (Non-linear growth factor)**: This constant factor determines the rate of price growth for elections with a maximum number of votes (maxCensusSize) exceeding the k7 threshold. By adjusting k6, you can control the non-linear growth rate of the price for larger elections. A higher k6 value would result in a more rapid increase in the price as the election size grows beyond the k7 threshold, while a lower k6 value would result in a slower increase in the price for larger elections. The rationale behind k6 is to provide a mechanism for controlling the pricing model&#39;s sensitivity to large elections. This factor ensures that the price accurately reflects the increased complexity, resource consumption, and management effort associated with larger elections, while maintaining a more affordable price for smaller elections. By fine-tuning k6, the pricing model can be adapted to balance accessibility for smaller elections with the need to cover costs and resource requirements for larger elections. - **k7 (Size non-linear trigger)**: This constant factor represents a threshold value for the maximum number of votes (maxCensusSize) in an election. When the election size exceeds k7, the price growth becomes non-linear, increasing more rapidly beyond this point. The rationale behind k7 is to create a pricing model that accommodates a \&quot;freemium\&quot; approach, where smaller elections (under the k7 threshold) are priced affordably, while larger elections are priced more significantly due to their increased resource requirements and complexity. By adjusting k7, you can control the point at which the price transition from linear to non-linear growth occurs. A higher k7 value would allow for more affordable pricing for a larger range of election sizes, while a lower k7 value would result in more rapid price increases for smaller election sizes. This flexibility enables the pricing model to be tailored to the specific needs and goals of the Vocdoni blockchain, ensuring that small elections remain accessible and affordable,while larger elections are priced to reflect their higher resource demands. 
     * @return ElectionpriceCalculator
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ElectionpriceCalculator chainInfoElectionPriceFactorsGet() throws ApiException {
        ApiResponse<ElectionpriceCalculator> localVarResp = chainInfoElectionPriceFactorsGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Price factors information
     * Package electionprice provides a mechanism for calculating the price of an election based on its characteristics.  The formula used to calculate the price for creating an election on the Vocdoni blockchain is designed to take into account various factors that impact the cost and complexity of conducting an election. The price is determined by combining several components, each reflecting a specific aspect of the election process.  1. **Base Price**: This is a fixed cost that serves as a starting point for the price calculation. It represents the minimal price for creating an election, regardless of its size or duration. 2. **Size Price**: As the number of voters (maxCensusSize) in an election increases, the resources required to manage the election also grow. To account for this, the size price component is directly proportional to the maximum number of votes allowed in the election. Additionally, it takes into consideration the blockchain&#39;s maximum capacity (capacity) and the maximum capacity the blockchain administrators can set (maxCapacity). This ensures that the price is adjusted based on the current capacity of the blockchain. 3. **Duration Price**: The length of the election (electionDuration) also affects the price, as longer elections occupy more resources over time. The duration price component is directly proportional to the election duration and inversely proportional to the maximum number of votes. This means that if the election lasts longer, the price increases, and if there are more votes in a shorter time, the price also increases to reflect the higher demand for resources. 4. **Encrypted Votes**: If an election requires encryption for maintaining secrecy until the end (encryptedVotes), it demands additional resources and computational effort. Therefore, the encrypted price component is added to the total price when this feature is enabled. 5. **Anonymous Votes**: Similarly, if an election must be anonymous (anonymousVotes), it requires additional measures to ensure voter privacy. As a result, the anonymous price component is added to the total price when this option is chosen. 6. **Overwrite Price**: Allowing voters to overwrite their votes (maxVoteOverwrite) can increase the complexity of managing the election, as it requires additional resources to handle vote updates. The overwrite price component accounts for this by being proportional to the maximum number of vote overwrites and the maximum number of votes allowed in the election. It also takes into account the blockchain&#39;s capacity to ensure the price reflects the current resource constraints.  The constant factors in the price formula play a crucial role in determining the price of an election based on its characteristics. Each factor is associated with a specific component of the price formula and helps to weigh the importance of that component in the final price calculation. The rationale beind these constant factors is to provide a flexible mechanism to adjust the pricing model based on the system&#39;s needs and requirements.  - **k1 (Size price factor)**: This constant factor affects the size price component of the formula. By adjusting k1, you can control the impact of the maximum number of votes (maxCensusSize) on the overall price. A higher k1 value would make the price increase more rapidly as the election size grows, while a lower k1 value would make the price less sensitive to the election size. The rationale behind k1 is to ensure that the pricing model can be adapted to accommodate different election sizes while considering the resource requirements. - **k2 (Duration price factor)**: This constant factor influences the duration price component of the formula. By adjusting k2, you can control how the duration of the election (electionDuration) affects the price. A higher k2 value would make the price increase more quickly as the election duration extends, while a lower k2 value would make the price less sensitive to the election duration. The rationale behind k2 is to reflect the resource consumption over time and ensure that longer elections are priced accordingly. - **k3 (Encrypted price factor)**: This constant factor affects the encrypted price component of the formula. By adjusting k3, you can control the additional cost associated with encrypted elections (encryptedVotes). A higher k3 value would make the price increase more significantly for elections that require encryption, while a lower k3 value would make the price less sensitive to the encryption requirement. The rationale behind k3 is to account for the extra computational effort and resources needed to ensure secrecy in encrypted elections. - **k4 (Anonymous price factor)**: This constant factor influences the anonymous price component of the formula. By adjusting k4, you can control the additional cost associated with anonymous elections (anonymousVotes). A higher k4 value would make the price increase more significantly for elections that require anonymity, while a lower k4 value would make the price less sensitive to the anonymity requirement. The rationale behind k4 is to account for the extra measures and resources needed to ensure voter privacy in anonymous elections. - **k5 (Overwrite price factor)**: This constant factor affects the overwrite price component of the formula. By adjusting k5, you can control the additional cost associated with allowing vote overwrites (maxVoteOverwrite). A higher k5 value would make the price increase more significantly for elections that permit vote overwrites, while a lower k5 value would make the price less sensitive to the overwrite allowance. The rationale behind k5 is to account for the increased complexity and resources needed to manage vote overwrites in the election process. - **k6 (Non-linear growth factor)**: This constant factor determines the rate of price growth for elections with a maximum number of votes (maxCensusSize) exceeding the k7 threshold. By adjusting k6, you can control the non-linear growth rate of the price for larger elections. A higher k6 value would result in a more rapid increase in the price as the election size grows beyond the k7 threshold, while a lower k6 value would result in a slower increase in the price for larger elections. The rationale behind k6 is to provide a mechanism for controlling the pricing model&#39;s sensitivity to large elections. This factor ensures that the price accurately reflects the increased complexity, resource consumption, and management effort associated with larger elections, while maintaining a more affordable price for smaller elections. By fine-tuning k6, the pricing model can be adapted to balance accessibility for smaller elections with the need to cover costs and resource requirements for larger elections. - **k7 (Size non-linear trigger)**: This constant factor represents a threshold value for the maximum number of votes (maxCensusSize) in an election. When the election size exceeds k7, the price growth becomes non-linear, increasing more rapidly beyond this point. The rationale behind k7 is to create a pricing model that accommodates a \&quot;freemium\&quot; approach, where smaller elections (under the k7 threshold) are priced affordably, while larger elections are priced more significantly due to their increased resource requirements and complexity. By adjusting k7, you can control the point at which the price transition from linear to non-linear growth occurs. A higher k7 value would allow for more affordable pricing for a larger range of election sizes, while a lower k7 value would result in more rapid price increases for smaller election sizes. This flexibility enables the pricing model to be tailored to the specific needs and goals of the Vocdoni blockchain, ensuring that small elections remain accessible and affordable,while larger elections are priced to reflect their higher resource demands. 
     * @return ApiResponse&lt;ElectionpriceCalculator&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ElectionpriceCalculator> chainInfoElectionPriceFactorsGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainInfoElectionPriceFactorsGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ElectionpriceCalculator>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Price factors information (asynchronously)
     * Package electionprice provides a mechanism for calculating the price of an election based on its characteristics.  The formula used to calculate the price for creating an election on the Vocdoni blockchain is designed to take into account various factors that impact the cost and complexity of conducting an election. The price is determined by combining several components, each reflecting a specific aspect of the election process.  1. **Base Price**: This is a fixed cost that serves as a starting point for the price calculation. It represents the minimal price for creating an election, regardless of its size or duration. 2. **Size Price**: As the number of voters (maxCensusSize) in an election increases, the resources required to manage the election also grow. To account for this, the size price component is directly proportional to the maximum number of votes allowed in the election. Additionally, it takes into consideration the blockchain&#39;s maximum capacity (capacity) and the maximum capacity the blockchain administrators can set (maxCapacity). This ensures that the price is adjusted based on the current capacity of the blockchain. 3. **Duration Price**: The length of the election (electionDuration) also affects the price, as longer elections occupy more resources over time. The duration price component is directly proportional to the election duration and inversely proportional to the maximum number of votes. This means that if the election lasts longer, the price increases, and if there are more votes in a shorter time, the price also increases to reflect the higher demand for resources. 4. **Encrypted Votes**: If an election requires encryption for maintaining secrecy until the end (encryptedVotes), it demands additional resources and computational effort. Therefore, the encrypted price component is added to the total price when this feature is enabled. 5. **Anonymous Votes**: Similarly, if an election must be anonymous (anonymousVotes), it requires additional measures to ensure voter privacy. As a result, the anonymous price component is added to the total price when this option is chosen. 6. **Overwrite Price**: Allowing voters to overwrite their votes (maxVoteOverwrite) can increase the complexity of managing the election, as it requires additional resources to handle vote updates. The overwrite price component accounts for this by being proportional to the maximum number of vote overwrites and the maximum number of votes allowed in the election. It also takes into account the blockchain&#39;s capacity to ensure the price reflects the current resource constraints.  The constant factors in the price formula play a crucial role in determining the price of an election based on its characteristics. Each factor is associated with a specific component of the price formula and helps to weigh the importance of that component in the final price calculation. The rationale beind these constant factors is to provide a flexible mechanism to adjust the pricing model based on the system&#39;s needs and requirements.  - **k1 (Size price factor)**: This constant factor affects the size price component of the formula. By adjusting k1, you can control the impact of the maximum number of votes (maxCensusSize) on the overall price. A higher k1 value would make the price increase more rapidly as the election size grows, while a lower k1 value would make the price less sensitive to the election size. The rationale behind k1 is to ensure that the pricing model can be adapted to accommodate different election sizes while considering the resource requirements. - **k2 (Duration price factor)**: This constant factor influences the duration price component of the formula. By adjusting k2, you can control how the duration of the election (electionDuration) affects the price. A higher k2 value would make the price increase more quickly as the election duration extends, while a lower k2 value would make the price less sensitive to the election duration. The rationale behind k2 is to reflect the resource consumption over time and ensure that longer elections are priced accordingly. - **k3 (Encrypted price factor)**: This constant factor affects the encrypted price component of the formula. By adjusting k3, you can control the additional cost associated with encrypted elections (encryptedVotes). A higher k3 value would make the price increase more significantly for elections that require encryption, while a lower k3 value would make the price less sensitive to the encryption requirement. The rationale behind k3 is to account for the extra computational effort and resources needed to ensure secrecy in encrypted elections. - **k4 (Anonymous price factor)**: This constant factor influences the anonymous price component of the formula. By adjusting k4, you can control the additional cost associated with anonymous elections (anonymousVotes). A higher k4 value would make the price increase more significantly for elections that require anonymity, while a lower k4 value would make the price less sensitive to the anonymity requirement. The rationale behind k4 is to account for the extra measures and resources needed to ensure voter privacy in anonymous elections. - **k5 (Overwrite price factor)**: This constant factor affects the overwrite price component of the formula. By adjusting k5, you can control the additional cost associated with allowing vote overwrites (maxVoteOverwrite). A higher k5 value would make the price increase more significantly for elections that permit vote overwrites, while a lower k5 value would make the price less sensitive to the overwrite allowance. The rationale behind k5 is to account for the increased complexity and resources needed to manage vote overwrites in the election process. - **k6 (Non-linear growth factor)**: This constant factor determines the rate of price growth for elections with a maximum number of votes (maxCensusSize) exceeding the k7 threshold. By adjusting k6, you can control the non-linear growth rate of the price for larger elections. A higher k6 value would result in a more rapid increase in the price as the election size grows beyond the k7 threshold, while a lower k6 value would result in a slower increase in the price for larger elections. The rationale behind k6 is to provide a mechanism for controlling the pricing model&#39;s sensitivity to large elections. This factor ensures that the price accurately reflects the increased complexity, resource consumption, and management effort associated with larger elections, while maintaining a more affordable price for smaller elections. By fine-tuning k6, the pricing model can be adapted to balance accessibility for smaller elections with the need to cover costs and resource requirements for larger elections. - **k7 (Size non-linear trigger)**: This constant factor represents a threshold value for the maximum number of votes (maxCensusSize) in an election. When the election size exceeds k7, the price growth becomes non-linear, increasing more rapidly beyond this point. The rationale behind k7 is to create a pricing model that accommodates a \&quot;freemium\&quot; approach, where smaller elections (under the k7 threshold) are priced affordably, while larger elections are priced more significantly due to their increased resource requirements and complexity. By adjusting k7, you can control the point at which the price transition from linear to non-linear growth occurs. A higher k7 value would allow for more affordable pricing for a larger range of election sizes, while a lower k7 value would result in more rapid price increases for smaller election sizes. This flexibility enables the pricing model to be tailored to the specific needs and goals of the Vocdoni blockchain, ensuring that small elections remain accessible and affordable,while larger elections are priced to reflect their higher resource demands. 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoElectionPriceFactorsGetAsync(final ApiCallback<ElectionpriceCalculator> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainInfoElectionPriceFactorsGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ElectionpriceCalculator>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainInfoGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainInfoGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainInfoGetCall(_callback);

    }

    /**
     * Vochain information
     * Return basic Vocdoni Blockchain (Vochain) information like blockTime, chainId, current height...  &#x60;blockTime&#x60;: each array position return average time for 1 minute, 10 minutes, 1 hour, 6 hours and 24 hours.  &#x60;blockTime&#x60;: every array position represents the average for 1 minute, 10m, 1h, 6h, 24h  &#x60;MaxCensusSize&#x60;: is a new feature introduced in the blockchain that is used to limit the number of  votes that can be registered for an election. This feature helps to prevent any potential overflow of the blockchain when the number of votes goes beyond the maximum limit. This is the maximum value  that an election creation can allow.  In order to create an election, the creator is required to set the &#x60;MaxCensusSize&#x60; parameter to a proper value. Typically, this value should be equal to the size of the census. If the MaxCensusSize parameter is set to 0, an error will occur and the election cannot be created.  The &#x60;MaxCensusSize&#x60; parameter determines the maximum number of votes that can be registered by the blockchain.  If the number of votes exceeds this limit, the vote transaction will fail (overwrite votes does not count).  See &#x60;MaxCensusSize&#x60; attribute on the VocdoniSDK  to add the maximum census size to a single election. Will throw an error if is superior than the allowed on the Vochain: &#x60;Max census size for the election is greater than allowed size&#x60;.  &#x60;networkCapacity&#x60;  indicates how many votes per block is the blockchain supposed to achieve. As bigger the capacity as cheaper the elections.
     * @return ApiChainInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiChainInfo chainInfoGet() throws ApiException {
        ApiResponse<ApiChainInfo> localVarResp = chainInfoGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Vochain information
     * Return basic Vocdoni Blockchain (Vochain) information like blockTime, chainId, current height...  &#x60;blockTime&#x60;: each array position return average time for 1 minute, 10 minutes, 1 hour, 6 hours and 24 hours.  &#x60;blockTime&#x60;: every array position represents the average for 1 minute, 10m, 1h, 6h, 24h  &#x60;MaxCensusSize&#x60;: is a new feature introduced in the blockchain that is used to limit the number of  votes that can be registered for an election. This feature helps to prevent any potential overflow of the blockchain when the number of votes goes beyond the maximum limit. This is the maximum value  that an election creation can allow.  In order to create an election, the creator is required to set the &#x60;MaxCensusSize&#x60; parameter to a proper value. Typically, this value should be equal to the size of the census. If the MaxCensusSize parameter is set to 0, an error will occur and the election cannot be created.  The &#x60;MaxCensusSize&#x60; parameter determines the maximum number of votes that can be registered by the blockchain.  If the number of votes exceeds this limit, the vote transaction will fail (overwrite votes does not count).  See &#x60;MaxCensusSize&#x60; attribute on the VocdoniSDK  to add the maximum census size to a single election. Will throw an error if is superior than the allowed on the Vochain: &#x60;Max census size for the election is greater than allowed size&#x60;.  &#x60;networkCapacity&#x60;  indicates how many votes per block is the blockchain supposed to achieve. As bigger the capacity as cheaper the elections.
     * @return ApiResponse&lt;ApiChainInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiChainInfo> chainInfoGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainInfoGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ApiChainInfo>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Vochain information (asynchronously)
     * Return basic Vocdoni Blockchain (Vochain) information like blockTime, chainId, current height...  &#x60;blockTime&#x60;: each array position return average time for 1 minute, 10 minutes, 1 hour, 6 hours and 24 hours.  &#x60;blockTime&#x60;: every array position represents the average for 1 minute, 10m, 1h, 6h, 24h  &#x60;MaxCensusSize&#x60;: is a new feature introduced in the blockchain that is used to limit the number of  votes that can be registered for an election. This feature helps to prevent any potential overflow of the blockchain when the number of votes goes beyond the maximum limit. This is the maximum value  that an election creation can allow.  In order to create an election, the creator is required to set the &#x60;MaxCensusSize&#x60; parameter to a proper value. Typically, this value should be equal to the size of the census. If the MaxCensusSize parameter is set to 0, an error will occur and the election cannot be created.  The &#x60;MaxCensusSize&#x60; parameter determines the maximum number of votes that can be registered by the blockchain.  If the number of votes exceeds this limit, the vote transaction will fail (overwrite votes does not count).  See &#x60;MaxCensusSize&#x60; attribute on the VocdoniSDK  to add the maximum census size to a single election. Will throw an error if is superior than the allowed on the Vochain: &#x60;Max census size for the election is greater than allowed size&#x60;.  &#x60;networkCapacity&#x60;  indicates how many votes per block is the blockchain supposed to achieve. As bigger the capacity as cheaper the elections.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainInfoGetAsync(final ApiCallback<ApiChainInfo> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainInfoGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ApiChainInfo>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainOrganizationsCountGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Number of registered organizations </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsCountGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/organizations/count";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainOrganizationsCountGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainOrganizationsCountGetCall(_callback);

    }

    /**
     * Count organizations
     * Return the number of organizations
     * @return ChainOrganizationsCountGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Number of registered organizations </td><td>  -  </td></tr>
     </table>
     */
    public ChainOrganizationsCountGet200Response chainOrganizationsCountGet() throws ApiException {
        ApiResponse<ChainOrganizationsCountGet200Response> localVarResp = chainOrganizationsCountGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Count organizations
     * Return the number of organizations
     * @return ApiResponse&lt;ChainOrganizationsCountGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Number of registered organizations </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChainOrganizationsCountGet200Response> chainOrganizationsCountGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainOrganizationsCountGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ChainOrganizationsCountGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Count organizations (asynchronously)
     * Return the number of organizations
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Number of registered organizations </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsCountGetAsync(final ApiCallback<ChainOrganizationsCountGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainOrganizationsCountGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ChainOrganizationsCountGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainOrganizationsFilterPagePagePost
     * @param page Current page (required)
     * @param chainOrganizationsFilterPagePagePostRequest Partial organizationId to filter by (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsFilterPagePagePostCall(Integer page, ChainOrganizationsFilterPagePagePostRequest chainOrganizationsFilterPagePagePostRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chainOrganizationsFilterPagePagePostRequest;

        // create path and map variables
        String localVarPath = "/chain/organizations/filter/page/{page}"
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainOrganizationsFilterPagePagePostValidateBeforeCall(Integer page, ChainOrganizationsFilterPagePagePostRequest chainOrganizationsFilterPagePagePostRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling chainOrganizationsFilterPagePagePost(Async)");
        }

        // verify the required parameter 'chainOrganizationsFilterPagePagePostRequest' is set
        if (chainOrganizationsFilterPagePagePostRequest == null) {
            throw new ApiException("Missing the required parameter 'chainOrganizationsFilterPagePagePostRequest' when calling chainOrganizationsFilterPagePagePost(Async)");
        }

        return chainOrganizationsFilterPagePagePostCall(page, chainOrganizationsFilterPagePagePostRequest, _callback);

    }

    /**
     * List organizations (filtered)
     * Returns a list of organizations filtered by its partial id, paginated by the given page
     * @param page Current page (required)
     * @param chainOrganizationsFilterPagePagePostRequest Partial organizationId to filter by (required)
     * @return ChainOrganizationsFilterPagePagePost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ChainOrganizationsFilterPagePagePost200Response chainOrganizationsFilterPagePagePost(Integer page, ChainOrganizationsFilterPagePagePostRequest chainOrganizationsFilterPagePagePostRequest) throws ApiException {
        ApiResponse<ChainOrganizationsFilterPagePagePost200Response> localVarResp = chainOrganizationsFilterPagePagePostWithHttpInfo(page, chainOrganizationsFilterPagePagePostRequest);
        return localVarResp.getData();
    }

    /**
     * List organizations (filtered)
     * Returns a list of organizations filtered by its partial id, paginated by the given page
     * @param page Current page (required)
     * @param chainOrganizationsFilterPagePagePostRequest Partial organizationId to filter by (required)
     * @return ApiResponse&lt;ChainOrganizationsFilterPagePagePost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ChainOrganizationsFilterPagePagePost200Response> chainOrganizationsFilterPagePagePostWithHttpInfo(Integer page, ChainOrganizationsFilterPagePagePostRequest chainOrganizationsFilterPagePagePostRequest) throws ApiException {
        okhttp3.Call localVarCall = chainOrganizationsFilterPagePagePostValidateBeforeCall(page, chainOrganizationsFilterPagePagePostRequest, null);
        Type localVarReturnType = new TypeToken<ChainOrganizationsFilterPagePagePost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List organizations (filtered) (asynchronously)
     * Returns a list of organizations filtered by its partial id, paginated by the given page
     * @param page Current page (required)
     * @param chainOrganizationsFilterPagePagePostRequest Partial organizationId to filter by (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsFilterPagePagePostAsync(Integer page, ChainOrganizationsFilterPagePagePostRequest chainOrganizationsFilterPagePagePostRequest, final ApiCallback<ChainOrganizationsFilterPagePagePost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainOrganizationsFilterPagePagePostValidateBeforeCall(page, chainOrganizationsFilterPagePagePostRequest, _callback);
        Type localVarReturnType = new TypeToken<ChainOrganizationsFilterPagePagePost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainOrganizationsPagePageGet
     * @param page Page number (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsPagePageGetCall(Integer page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/organizations/page/{page}"
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainOrganizationsPagePageGetValidateBeforeCall(Integer page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling chainOrganizationsPagePageGet(Async)");
        }

        return chainOrganizationsPagePageGetCall(page, _callback);

    }

    /**
     * List organizations
     * An **Organizations** is an account with &#x60;infoUri&#x60; that contains organization associated  metadata.  An **Account** instead could be a validator, an oracle, a voter or just someone who wants to transfer tokens.   The &#x60;/chain/organizations&#x60; endpoints are related only to the Organization account type.  - Return list of organizations ids. - If no page is defined, will assume page 0.
     * @param page Page number (required)
     * @return ApiOrganizationListHandlerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiOrganizationListHandlerResponse chainOrganizationsPagePageGet(Integer page) throws ApiException {
        ApiResponse<ApiOrganizationListHandlerResponse> localVarResp = chainOrganizationsPagePageGetWithHttpInfo(page);
        return localVarResp.getData();
    }

    /**
     * List organizations
     * An **Organizations** is an account with &#x60;infoUri&#x60; that contains organization associated  metadata.  An **Account** instead could be a validator, an oracle, a voter or just someone who wants to transfer tokens.   The &#x60;/chain/organizations&#x60; endpoints are related only to the Organization account type.  - Return list of organizations ids. - If no page is defined, will assume page 0.
     * @param page Page number (required)
     * @return ApiResponse&lt;ApiOrganizationListHandlerResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiOrganizationListHandlerResponse> chainOrganizationsPagePageGetWithHttpInfo(Integer page) throws ApiException {
        okhttp3.Call localVarCall = chainOrganizationsPagePageGetValidateBeforeCall(page, null);
        Type localVarReturnType = new TypeToken<ApiOrganizationListHandlerResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List organizations (asynchronously)
     * An **Organizations** is an account with &#x60;infoUri&#x60; that contains organization associated  metadata.  An **Account** instead could be a validator, an oracle, a voter or just someone who wants to transfer tokens.   The &#x60;/chain/organizations&#x60; endpoints are related only to the Organization account type.  - Return list of organizations ids. - If no page is defined, will assume page 0.
     * @param page Page number (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainOrganizationsPagePageGetAsync(Integer page, final ApiCallback<ApiOrganizationListHandlerResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainOrganizationsPagePageGetValidateBeforeCall(page, _callback);
        Type localVarReturnType = new TypeToken<ApiOrganizationListHandlerResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsCostGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsCostGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/cost";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsCostGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainTransactionsCostGetCall(_callback);

    }

    /**
     * Transaction costs
     * Returns the list of transactions and its cost
     * @return GenesisTransactionCosts
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GenesisTransactionCosts chainTransactionsCostGet() throws ApiException {
        ApiResponse<GenesisTransactionCosts> localVarResp = chainTransactionsCostGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Transaction costs
     * Returns the list of transactions and its cost
     * @return ApiResponse&lt;GenesisTransactionCosts&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GenesisTransactionCosts> chainTransactionsCostGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsCostGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GenesisTransactionCosts>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transaction costs (asynchronously)
     * Returns the list of transactions and its cost
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsCostGetAsync(final ApiCallback<GenesisTransactionCosts> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsCostGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GenesisTransactionCosts>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsCountGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsCountGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/count";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsCountGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainTransactionsCountGetCall(_callback);

    }

    /**
     * Transactions count
     * Returns the number of transactions
     * @return AccountsOrganizationIDElectionsCountGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public AccountsOrganizationIDElectionsCountGet200Response chainTransactionsCountGet() throws ApiException {
        ApiResponse<AccountsOrganizationIDElectionsCountGet200Response> localVarResp = chainTransactionsCountGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Transactions count
     * Returns the number of transactions
     * @return ApiResponse&lt;AccountsOrganizationIDElectionsCountGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AccountsOrganizationIDElectionsCountGet200Response> chainTransactionsCountGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsCountGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<AccountsOrganizationIDElectionsCountGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transactions count (asynchronously)
     * Returns the number of transactions
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsCountGetAsync(final ApiCallback<AccountsOrganizationIDElectionsCountGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsCountGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<AccountsOrganizationIDElectionsCountGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsHeightIndexGet
     * @param height Block height (required)
     * @param index Transaction index on block (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsHeightIndexGetCall(Integer height, Integer index, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/{height}/{index}"
            .replace("{" + "height" + "}", localVarApiClient.escapeString(height.toString()))
            .replace("{" + "index" + "}", localVarApiClient.escapeString(index.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsHeightIndexGetValidateBeforeCall(Integer height, Integer index, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'height' is set
        if (height == null) {
            throw new ApiException("Missing the required parameter 'height' when calling chainTransactionsHeightIndexGet(Async)");
        }

        // verify the required parameter 'index' is set
        if (index == null) {
            throw new ApiException("Missing the required parameter 'index' when calling chainTransactionsHeightIndexGet(Async)");
        }

        return chainTransactionsHeightIndexGetCall(height, index, _callback);

    }

    /**
     * Transaction by block height and index
     * Get transaction full information by block height and index. It returns JSON transaction protobuf encoded. Depending of transaction type will return different types of objects. Current transaction types can be found calling &#x60;/chain/transactions/cost&#x60;
     * @param height Block height (required)
     * @param index Transaction index on block (required)
     * @return ApiGenericTransactionWithInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public ApiGenericTransactionWithInfo chainTransactionsHeightIndexGet(Integer height, Integer index) throws ApiException {
        ApiResponse<ApiGenericTransactionWithInfo> localVarResp = chainTransactionsHeightIndexGetWithHttpInfo(height, index);
        return localVarResp.getData();
    }

    /**
     * Transaction by block height and index
     * Get transaction full information by block height and index. It returns JSON transaction protobuf encoded. Depending of transaction type will return different types of objects. Current transaction types can be found calling &#x60;/chain/transactions/cost&#x60;
     * @param height Block height (required)
     * @param index Transaction index on block (required)
     * @return ApiResponse&lt;ApiGenericTransactionWithInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiGenericTransactionWithInfo> chainTransactionsHeightIndexGetWithHttpInfo(Integer height, Integer index) throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsHeightIndexGetValidateBeforeCall(height, index, null);
        Type localVarReturnType = new TypeToken<ApiGenericTransactionWithInfo>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transaction by block height and index (asynchronously)
     * Get transaction full information by block height and index. It returns JSON transaction protobuf encoded. Depending of transaction type will return different types of objects. Current transaction types can be found calling &#x60;/chain/transactions/cost&#x60;
     * @param height Block height (required)
     * @param index Transaction index on block (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsHeightIndexGetAsync(Integer height, Integer index, final ApiCallback<ApiGenericTransactionWithInfo> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsHeightIndexGetValidateBeforeCall(height, index, _callback);
        Type localVarReturnType = new TypeToken<ApiGenericTransactionWithInfo>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsPagePageGet
     * @param page Page number (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return a list of transactions references </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsPagePageGetCall(Integer page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/page/{page}"
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsPagePageGetValidateBeforeCall(Integer page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling chainTransactionsPagePageGet(Async)");
        }

        return chainTransactionsPagePageGetCall(page, _callback);

    }

    /**
     * List Transactions
     * To get full transaction information use  [/chain/transaction/{blockHeight}/{txIndex}](transaction-by-block-index).\\nWhere transactionIndex is the index of the transaction on the containing block.
     * @param page Page number (required)
     * @return ApiChainTxListPaginatedResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return a list of transactions references </td><td>  -  </td></tr>
     </table>
     */
    public ApiChainTxListPaginatedResponse chainTransactionsPagePageGet(Integer page) throws ApiException {
        ApiResponse<ApiChainTxListPaginatedResponse> localVarResp = chainTransactionsPagePageGetWithHttpInfo(page);
        return localVarResp.getData();
    }

    /**
     * List Transactions
     * To get full transaction information use  [/chain/transaction/{blockHeight}/{txIndex}](transaction-by-block-index).\\nWhere transactionIndex is the index of the transaction on the containing block.
     * @param page Page number (required)
     * @return ApiResponse&lt;ApiChainTxListPaginatedResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return a list of transactions references </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiChainTxListPaginatedResponse> chainTransactionsPagePageGetWithHttpInfo(Integer page) throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsPagePageGetValidateBeforeCall(page, null);
        Type localVarReturnType = new TypeToken<ApiChainTxListPaginatedResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Transactions (asynchronously)
     * To get full transaction information use  [/chain/transaction/{blockHeight}/{txIndex}](transaction-by-block-index).\\nWhere transactionIndex is the index of the transaction on the containing block.
     * @param page Page number (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> It return a list of transactions references </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsPagePageGetAsync(Integer page, final ApiCallback<ApiChainTxListPaginatedResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsPagePageGetValidateBeforeCall(page, _callback);
        Type localVarReturnType = new TypeToken<ApiChainTxListPaginatedResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsPost
     * @param chainTransactionsPostRequest Base64 payload string containing transaction data and signature (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Return blockchain response. &#x60;response&#x60; could differ depending of transaction type. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsPostCall(ChainTransactionsPostRequest chainTransactionsPostRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chainTransactionsPostRequest;

        // create path and map variables
        String localVarPath = "/chain/transactions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsPostValidateBeforeCall(ChainTransactionsPostRequest chainTransactionsPostRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'chainTransactionsPostRequest' is set
        if (chainTransactionsPostRequest == null) {
            throw new ApiException("Missing the required parameter 'chainTransactionsPostRequest' when calling chainTransactionsPost(Async)");
        }

        return chainTransactionsPostCall(chainTransactionsPostRequest, _callback);

    }

    /**
     * Submit transaction
     * It submit a transaction. Depending of transaction type will return different kinds of responses: - For a NewElection transaction, &#x60;response&#x60; will be the &#x60;newElectionId&#x60; - For a Vote transaction, &#x60;response&#x60; will be the &#x60;voteID&#x60;  Once the transaction is mined on the Vochain you can use [&#x60;chain/transactions/reference/{hash}&#x60;](transaction-by-reference) to find the block height and its index on the block to get the transaction index using [&#x60;chain/transactions/{blockHeight}/{txIndex}&#x60;](transaction-by-block-index). 
     * @param chainTransactionsPostRequest Base64 payload string containing transaction data and signature (required)
     * @return ApiTransaction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Return blockchain response. &#x60;response&#x60; could differ depending of transaction type. </td><td>  -  </td></tr>
     </table>
     */
    public ApiTransaction chainTransactionsPost(ChainTransactionsPostRequest chainTransactionsPostRequest) throws ApiException {
        ApiResponse<ApiTransaction> localVarResp = chainTransactionsPostWithHttpInfo(chainTransactionsPostRequest);
        return localVarResp.getData();
    }

    /**
     * Submit transaction
     * It submit a transaction. Depending of transaction type will return different kinds of responses: - For a NewElection transaction, &#x60;response&#x60; will be the &#x60;newElectionId&#x60; - For a Vote transaction, &#x60;response&#x60; will be the &#x60;voteID&#x60;  Once the transaction is mined on the Vochain you can use [&#x60;chain/transactions/reference/{hash}&#x60;](transaction-by-reference) to find the block height and its index on the block to get the transaction index using [&#x60;chain/transactions/{blockHeight}/{txIndex}&#x60;](transaction-by-block-index). 
     * @param chainTransactionsPostRequest Base64 payload string containing transaction data and signature (required)
     * @return ApiResponse&lt;ApiTransaction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Return blockchain response. &#x60;response&#x60; could differ depending of transaction type. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiTransaction> chainTransactionsPostWithHttpInfo(ChainTransactionsPostRequest chainTransactionsPostRequest) throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsPostValidateBeforeCall(chainTransactionsPostRequest, null);
        Type localVarReturnType = new TypeToken<ApiTransaction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Submit transaction (asynchronously)
     * It submit a transaction. Depending of transaction type will return different kinds of responses: - For a NewElection transaction, &#x60;response&#x60; will be the &#x60;newElectionId&#x60; - For a Vote transaction, &#x60;response&#x60; will be the &#x60;voteID&#x60;  Once the transaction is mined on the Vochain you can use [&#x60;chain/transactions/reference/{hash}&#x60;](transaction-by-reference) to find the block height and its index on the block to get the transaction index using [&#x60;chain/transactions/{blockHeight}/{txIndex}&#x60;](transaction-by-block-index). 
     * @param chainTransactionsPostRequest Base64 payload string containing transaction data and signature (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Return blockchain response. &#x60;response&#x60; could differ depending of transaction type. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsPostAsync(ChainTransactionsPostRequest chainTransactionsPostRequest, final ApiCallback<ApiTransaction> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsPostValidateBeforeCall(chainTransactionsPostRequest, _callback);
        Type localVarReturnType = new TypeToken<ApiTransaction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsReferenceHashGet
     * @param hash Transaction hash (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsReferenceHashGetCall(String hash, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/reference/{hash}"
            .replace("{" + "hash" + "}", localVarApiClient.escapeString(hash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsReferenceHashGetValidateBeforeCall(String hash, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'hash' is set
        if (hash == null) {
            throw new ApiException("Missing the required parameter 'hash' when calling chainTransactionsReferenceHashGet(Async)");
        }

        return chainTransactionsReferenceHashGetCall(hash, _callback);

    }

    /**
     * Transaction by hash
     * Using transaction hash it return the &#x60;block&#x60; and &#x60;index&#x60; containing that contains the transaction. After, you could use this &#x60;block&#x60; and &#x60;index&#x60; to retrieve transaction full info using [transaction by block and index](transaction-by-block-index)
     * @param hash Transaction hash (required)
     * @return IndexertypesTransaction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public IndexertypesTransaction chainTransactionsReferenceHashGet(String hash) throws ApiException {
        ApiResponse<IndexertypesTransaction> localVarResp = chainTransactionsReferenceHashGetWithHttpInfo(hash);
        return localVarResp.getData();
    }

    /**
     * Transaction by hash
     * Using transaction hash it return the &#x60;block&#x60; and &#x60;index&#x60; containing that contains the transaction. After, you could use this &#x60;block&#x60; and &#x60;index&#x60; to retrieve transaction full info using [transaction by block and index](transaction-by-block-index)
     * @param hash Transaction hash (required)
     * @return ApiResponse&lt;IndexertypesTransaction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexertypesTransaction> chainTransactionsReferenceHashGetWithHttpInfo(String hash) throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsReferenceHashGetValidateBeforeCall(hash, null);
        Type localVarReturnType = new TypeToken<IndexertypesTransaction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transaction by hash (asynchronously)
     * Using transaction hash it return the &#x60;block&#x60; and &#x60;index&#x60; containing that contains the transaction. After, you could use this &#x60;block&#x60; and &#x60;index&#x60; to retrieve transaction full info using [transaction by block and index](transaction-by-block-index)
     * @param hash Transaction hash (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsReferenceHashGetAsync(String hash, final ApiCallback<IndexertypesTransaction> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsReferenceHashGetValidateBeforeCall(hash, _callback);
        Type localVarReturnType = new TypeToken<IndexertypesTransaction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainTransactionsReferenceIndexIndexGet
     * @param index Index of the transaction (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsReferenceIndexIndexGetCall(Integer index, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/transactions/reference/index/{index}"
            .replace("{" + "index" + "}", localVarApiClient.escapeString(index.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainTransactionsReferenceIndexIndexGetValidateBeforeCall(Integer index, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'index' is set
        if (index == null) {
            throw new ApiException("Missing the required parameter 'index' when calling chainTransactionsReferenceIndexIndexGet(Async)");
        }

        return chainTransactionsReferenceIndexIndexGetCall(index, _callback);

    }

    /**
     * Transaction by index
     * Get transaction by its index. This is not transaction reference (hash), and neither the block height and block  index. The transaction index is an incremental counter for each transaction.  You could use the transaction &#x60;block&#x60; and &#x60;index&#x60; to retrieve full info using [transaction by block and index](transaction-by-block-index).
     * @param index Index of the transaction (required)
     * @return IndexertypesTransaction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public IndexertypesTransaction chainTransactionsReferenceIndexIndexGet(Integer index) throws ApiException {
        ApiResponse<IndexertypesTransaction> localVarResp = chainTransactionsReferenceIndexIndexGetWithHttpInfo(index);
        return localVarResp.getData();
    }

    /**
     * Transaction by index
     * Get transaction by its index. This is not transaction reference (hash), and neither the block height and block  index. The transaction index is an incremental counter for each transaction.  You could use the transaction &#x60;block&#x60; and &#x60;index&#x60; to retrieve full info using [transaction by block and index](transaction-by-block-index).
     * @param index Index of the transaction (required)
     * @return ApiResponse&lt;IndexertypesTransaction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexertypesTransaction> chainTransactionsReferenceIndexIndexGetWithHttpInfo(Integer index) throws ApiException {
        okhttp3.Call localVarCall = chainTransactionsReferenceIndexIndexGetValidateBeforeCall(index, null);
        Type localVarReturnType = new TypeToken<IndexertypesTransaction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Transaction by index (asynchronously)
     * Get transaction by its index. This is not transaction reference (hash), and neither the block height and block  index. The transaction index is an incremental counter for each transaction.  You could use the transaction &#x60;block&#x60; and &#x60;index&#x60; to retrieve full info using [transaction by block and index](transaction-by-block-index).
     * @param index Index of the transaction (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> See [errors](vocdoni-api#errors) section </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainTransactionsReferenceIndexIndexGetAsync(Integer index, final ApiCallback<IndexertypesTransaction> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainTransactionsReferenceIndexIndexGetValidateBeforeCall(index, _callback);
        Type localVarReturnType = new TypeToken<IndexertypesTransaction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for chainValidatorsGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainValidatorsGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chain/validators";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call chainValidatorsGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return chainValidatorsGetCall(_callback);

    }

    /**
     * List validators
     * Returns the list of validators
     * @return ApiValidatorList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiValidatorList chainValidatorsGet() throws ApiException {
        ApiResponse<ApiValidatorList> localVarResp = chainValidatorsGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List validators
     * Returns the list of validators
     * @return ApiResponse&lt;ApiValidatorList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiValidatorList> chainValidatorsGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = chainValidatorsGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ApiValidatorList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List validators (asynchronously)
     * Returns the list of validators
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call chainValidatorsGetAsync(final ApiCallback<ApiValidatorList> _callback) throws ApiException {

        okhttp3.Call localVarCall = chainValidatorsGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ApiValidatorList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
